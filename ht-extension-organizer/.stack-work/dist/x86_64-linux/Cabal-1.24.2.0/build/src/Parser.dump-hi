
==================== FINAL INTERFACE ====================
2017-09-05 20:17:10.598253 UTC

interface ht-extension-organizer-0.1.0.0-y3uypH7gCtA60AaWeuyZL:Parser 8002
  interface hash: 693db0de42c4495ebf1568a270286eb5
  ABI hash: 77ce690f6247fd99ccb953c8714523de
  export-list hash: 517a04406f0420b909851443746cbeba
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: ab396f11155bd696ab63895436e6f1df
  sig of: Nothing
  used TH splices: True
  where
exports:
  Parser.char
  Parser.decimal
  Parser.digit
  Parser.endParsing
  Parser.matches
  Parser.runParser
  Parser.string
  Parser.times
  Parser.token
  Parser.whitespace
  Parser.Parser{Parser.P}
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Control.Applicative 32430a90492e727f4bd80db71c28600c
import  -/  base-4.9.1.0:Data.Char 01433d23661edb6e5ef1536ef1e6774c
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.Functor 5ab1dc703df5b482e77efb697833ca3c
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:GHC.Unicode a175ecf20bf1272d9ae31337e7da43ab
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
Module target ht-extension-organizer-0.1.0.0-y3uypH7gCtA60AaWeuyZL:Parser annotated by 1059 of type [Char]
948d49e54bee281d889cfa5822c93c4c
  $fAlternativeParser :: GHC.Base.Alternative Parser.Parser
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Parser.Parser
                  Parser.$fApplicativeParser
                  Parser.$fAlternativeParser_$cempty
                  Parser.$fAlternativeParser_$c<|>
                  Parser.$fAlternativeParser_$csome
                  Parser.$fAlternativeParser_$cmany -}
948d49e54bee281d889cfa5822c93c4c
  $fAlternativeParser1 ::
    Parser.Parser a -> GHC.Base.String -> [([a], GHC.Base.String)]
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),C(U)><L,U>,
     Unfolding: (\ @ a
                   (eta :: Parser.Parser a)
                   (eta1 :: GHC.Base.String) ->
                 letrec {
                   many_v :: GHC.Base.String -> [([a], GHC.Base.String)]
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ (s :: GHC.Base.String) ->
                     let {
                       z :: ([a], GHC.Base.String) {- Strictness: m -}
                       = (GHC.Types.[] @ a, s)
                     } in
                     let {
                       z1 :: [([a], GHC.Base.String)]
                       = GHC.Types.:
                           @ ([a], GHC.Base.String)
                           z
                           (GHC.Types.[] @ ([a], GHC.Base.String))
                     } in
                     letrec {
                       go :: [(a, GHC.Base.String)] -> [([a], GHC.Base.String)]
                         {- Arity: 1, Strictness: <S,1*U> -}
                       = \ (ds :: [(a, GHC.Base.String)]) ->
                         case ds of wild {
                           [] -> z1
                           : y ys
                           -> case y of wild1 { (,) x s' ->
                              let {
                                z2 :: [([a], GHC.Base.String)] = go ys
                              } in
                              letrec {
                                go1 :: [([a], GHC.Base.String)] -> [([a], GHC.Base.String)]
                                  {- Arity: 1, Strictness: <S,1*U> -}
                                = \ (ds1 :: [([a], GHC.Base.String)]) ->
                                  case ds1 of wild2 {
                                    [] -> z2
                                    : y1 ys1
                                    -> case y1 of wild3 { (,) x1 s'' ->
                                       GHC.Types.:
                                         @ ([a], GHC.Base.String)
                                         (GHC.Types.: @ a x x1, s'')
                                         (go1 ys1) } }
                              } in
                              go1 (many_v s') } }
                     } in
                     go (eta `cast` (Parser.N:Parser[0] <a>_R) s)
                 } in
                 many_v eta1) -}
948d49e54bee281d889cfa5822c93c4c
  $fAlternativeParser2 ::
    Parser.Parser a -> GHC.Base.String -> [([a], GHC.Base.String)]
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),C(U)><L,U>,
     Unfolding: (\ @ a
                   (eta :: Parser.Parser a)
                   (eta1 :: GHC.Base.String) ->
                 letrec {
                   go :: [(a, GHC.Base.String)] -> [([a], GHC.Base.String)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(a, GHC.Base.String)]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ ([a], GHC.Base.String)
                       : y ys
                       -> case y of wild1 { (,) x s' ->
                          let {
                            z :: [a] = GHC.Types.: @ a x (GHC.Types.[] @ a)
                          } in
                          let {
                            z1 :: ([a], GHC.Base.String) {- Strictness: m -} = (z, s')
                          } in
                          let {
                            z2 :: [([a], GHC.Base.String)] = go ys
                          } in
                          let {
                            z3 :: [([a], GHC.Base.String)]
                            = GHC.Types.: @ ([a], GHC.Base.String) z1 z2
                          } in
                          letrec {
                            go1 :: [([a], GHC.Base.String)] -> [([a], GHC.Base.String)]
                              {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [([a], GHC.Base.String)]) ->
                              case ds1 of wild2 {
                                [] -> z3
                                : y1 ys1
                                -> case y1 of wild3 { (,) x1 s'' ->
                                   GHC.Types.:
                                     @ ([a], GHC.Base.String)
                                     (GHC.Types.: @ a x x1, s'')
                                     (go1 ys1) } }
                          } in
                          go1 (go (eta `cast` (Parser.N:Parser[0] <a>_R) s')) } }
                 } in
                 go (eta `cast` (Parser.N:Parser[0] <a>_R) eta1)) -}
948d49e54bee281d889cfa5822c93c4c
  $fAlternativeParser3 ::
    Parser.Parser a
    -> Parser.Parser a -> GHC.Base.String -> [(a, GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (ds :: Parser.Parser a)
                   (ds1 :: Parser.Parser a)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ (a, GHC.Base.String)
                   (\ @ b
                      (c :: (a, GHC.Base.String) -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ (a, GHC.Base.String)
                      @ b
                      c
                      n
                      (ds `cast` (Parser.N:Parser[0] <a>_R) s))
                   (ds1 `cast` (Parser.N:Parser[0] <a>_R) s)) -}
84d206e3877c8a3b3dbacde8e3289874
  $fAlternativeParser4 :: GHC.Base.String -> [(a, GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (ds :: GHC.Base.String) ->
                 GHC.Types.[] @ (a, GHC.Base.String)) -}
948d49e54bee281d889cfa5822c93c4c
  $fAlternativeParser_$c<|> ::
    Parser.Parser a -> Parser.Parser a -> Parser.Parser a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fAlternativeParser3
                  `cast`
                (forall (a :: <*>_N).
                 <Parser.Parser a>_R
                 ->_R <Parser.Parser a>_R
                 ->_R Sym (Parser.N:Parser[0] <a>_R)) -}
948d49e54bee281d889cfa5822c93c4c
  $fAlternativeParser_$cempty :: Parser.Parser a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fAlternativeParser4
                  `cast`
                (forall (a :: <*>_N). Sym (Parser.N:Parser[0] <a>_R)) -}
948d49e54bee281d889cfa5822c93c4c
  $fAlternativeParser_$cmany :: Parser.Parser a -> Parser.Parser [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),C(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fAlternativeParser1
                  `cast`
                (forall (a :: <*>_N).
                 <Parser.Parser a>_R ->_R Sym (Parser.N:Parser[0] <[a]>_R)) -}
948d49e54bee281d889cfa5822c93c4c
  $fAlternativeParser_$csome :: Parser.Parser a -> Parser.Parser [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),C(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fAlternativeParser2
                  `cast`
                (forall (a :: <*>_N).
                 <Parser.Parser a>_R ->_R Sym (Parser.N:Parser[0] <[a]>_R)) -}
948d49e54bee281d889cfa5822c93c4c
  $fApplicativeParser :: GHC.Base.Applicative Parser.Parser
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Parser.Parser
                  Parser.$fFunctorParser
                  Parser.$fApplicativeParser_$cpure
                  Parser.$fApplicativeParser_$c<*>
                  Parser.$fApplicativeParser_$c*>
                  Parser.$fApplicativeParser_$c<* -}
948d49e54bee281d889cfa5822c93c4c
  $fApplicativeParser1 ::
    Parser.Parser a
    -> Parser.Parser b -> GHC.Base.String -> [(a, GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,C(U)><L,U>,
     Unfolding: (\ @ b
                   @ a
                   (eta :: Parser.Parser a)
                   (eta1 :: Parser.Parser b)
                   (eta2 :: GHC.Base.String) ->
                 Parser.$fApplicativeParser3
                   @ b
                   @ a
                   (\ (s :: GHC.Base.String)[OneShot] ->
                    Parser.$fApplicativeParser2
                      @ b
                      @ a
                      (eta `cast` (Parser.N:Parser[0] <a>_R) s))
                     `cast`
                   (Sym (Parser.N:Parser[0] <b -> a>_R))
                   eta1
                   eta2) -}
a6b5b4c425f9ff740a10faaaa613f16d
  $fApplicativeParser2 ::
    [(a, GHC.Base.String)] -> [(b -> a, GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
948d49e54bee281d889cfa5822c93c4c
  $fApplicativeParser3 ::
    Parser.Parser (a -> b)
    -> Parser.Parser a -> GHC.Base.String -> [(b, GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,C(U)><L,U>,
     Unfolding: (\ @ a
                   @ b
                   (ds :: Parser.Parser (a -> b))
                   (ds1 :: Parser.Parser a)
                   (s :: GHC.Base.String) ->
                 letrec {
                   go :: [(a -> b, GHC.Base.String)] -> [(b, GHC.Base.String)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds2 :: [(a -> b, GHC.Base.String)]) ->
                     case ds2 of wild {
                       [] -> GHC.Types.[] @ (b, GHC.Base.String)
                       : y ys
                       -> case y of wild1 { (,) f s' ->
                          let {
                            z :: [(b, GHC.Base.String)] = go ys
                          } in
                          letrec {
                            go1 :: [(a, GHC.Base.String)] -> [(b, GHC.Base.String)]
                              {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds3 :: [(a, GHC.Base.String)]) ->
                              case ds3 of wild2 {
                                [] -> z
                                : y1 ys1
                                -> case y1 of wild3 { (,) x s'' ->
                                   GHC.Types.: @ (b, GHC.Base.String) (f x, s'') (go1 ys1) } }
                          } in
                          go1 (ds1 `cast` (Parser.N:Parser[0] <a>_R) s') } }
                 } in
                 go (ds `cast` (Parser.N:Parser[0] <a -> b>_R) s)) -}
948d49e54bee281d889cfa5822c93c4c
  $fApplicativeParser4 ::
    Parser.Parser a
    -> Parser.Parser b -> GHC.Base.String -> [(b, GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,C(U)><L,U>,
     Unfolding: (\ @ b
                   @ a
                   (eta :: Parser.Parser a)
                   (eta1 :: Parser.Parser b)
                   (eta2 :: GHC.Base.String) ->
                 Parser.$fApplicativeParser3
                   @ b
                   @ b
                   (\ (s :: GHC.Base.String)[OneShot] ->
                    Parser.$fApplicativeParser5
                      @ b
                      @ a
                      (eta `cast` (Parser.N:Parser[0] <a>_R) s))
                     `cast`
                   (Sym (Parser.N:Parser[0] <b -> b>_R))
                   eta1
                   eta2) -}
0742e478c808766f2061c991389dc349
  $fApplicativeParser5 ::
    [(a, GHC.Base.String)] -> [(b -> b, GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
3e8dd4889315b8bf02bc86fda5ef3736
  $fApplicativeParser6 ::
    a -> GHC.Base.String -> [(a, GHC.Base.String)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (x :: a) (s :: GHC.Base.String) ->
                 GHC.Types.:
                   @ (a, GHC.Base.String)
                   (x, s)
                   (GHC.Types.[] @ (a, GHC.Base.String))) -}
948d49e54bee281d889cfa5822c93c4c
  $fApplicativeParser_$c*> ::
    Parser.Parser a -> Parser.Parser b -> Parser.Parser b
  {- Arity: 3, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,C(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ b -> Parser.$fApplicativeParser4 @ b @ a)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Parser.Parser a>_R
                 ->_R <Parser.Parser b>_R
                 ->_R Sym (Parser.N:Parser[0] <b>_R)) -}
948d49e54bee281d889cfa5822c93c4c
  $fApplicativeParser_$c<* ::
    Parser.Parser a -> Parser.Parser b -> Parser.Parser a
  {- Arity: 3, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,C(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ b -> Parser.$fApplicativeParser1 @ b @ a)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Parser.Parser a>_R
                 ->_R <Parser.Parser b>_R
                 ->_R Sym (Parser.N:Parser[0] <a>_R)) -}
948d49e54bee281d889cfa5822c93c4c
  $fApplicativeParser_$c<*> ::
    Parser.Parser (a -> b) -> Parser.Parser a -> Parser.Parser b
  {- Arity: 3, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,C(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fApplicativeParser3
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Parser.Parser (a -> b)>_R
                 ->_R <Parser.Parser a>_R
                 ->_R Sym (Parser.N:Parser[0] <b>_R)) -}
948d49e54bee281d889cfa5822c93c4c
  $fApplicativeParser_$cpure :: a -> Parser.Parser a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Unfolding: InlineRule (0, True, True)
                Parser.$fApplicativeParser6
                  `cast`
                (forall (a :: <*>_N). <a>_R ->_R Sym (Parser.N:Parser[0] <a>_R)) -}
948d49e54bee281d889cfa5822c93c4c
  $fFunctorParser :: GHC.Base.Functor Parser.Parser
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Parser.Parser
                  Parser.$fFunctorParser_$cfmap
                  Parser.$fFunctorParser_$c<$ -}
948d49e54bee281d889cfa5822c93c4c
  $fFunctorParser1 ::
    a -> Parser.Parser b -> GHC.Base.String -> [(a, GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)><L,U>,
     Unfolding: (\ @ b
                   @ a
                   (eta :: a)
                   (ds :: Parser.Parser b)
                   (s :: GHC.Base.String) ->
                 letrec {
                   go :: [(b, GHC.Base.String)] -> [(a, GHC.Base.String)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds1 :: [(b, GHC.Base.String)]) ->
                     case ds1 of wild {
                       [] -> GHC.Types.[] @ (a, GHC.Base.String)
                       : y ys
                       -> case y of wild1 { (,) x s' ->
                          GHC.Types.: @ (a, GHC.Base.String) (eta, s') (go ys) } }
                 } in
                 go (ds `cast` (Parser.N:Parser[0] <b>_R) s)) -}
948d49e54bee281d889cfa5822c93c4c
  $fFunctorParser2 ::
    (a -> b)
    -> Parser.Parser a -> GHC.Base.String -> [(b, GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(U)><C(S),1*C1(U)><L,U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Parser.Parser a)
                   (s :: GHC.Base.String) ->
                 letrec {
                   go :: [(a, GHC.Base.String)] -> [(b, GHC.Base.String)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds1 :: [(a, GHC.Base.String)]) ->
                     case ds1 of wild {
                       [] -> GHC.Types.[] @ (b, GHC.Base.String)
                       : y ys
                       -> case y of wild1 { (,) x s' ->
                          GHC.Types.: @ (b, GHC.Base.String) (f x, s') (go ys) } }
                 } in
                 go (ds `cast` (Parser.N:Parser[0] <a>_R) s)) -}
948d49e54bee281d889cfa5822c93c4c
  $fFunctorParser_$c<$ :: a -> Parser.Parser b -> Parser.Parser a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ b -> Parser.$fFunctorParser1 @ b @ a)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a>_R
                 ->_R <Parser.Parser b>_R
                 ->_R Sym (Parser.N:Parser[0] <a>_R)) -}
948d49e54bee281d889cfa5822c93c4c
  $fFunctorParser_$cfmap ::
    (a -> b) -> Parser.Parser a -> Parser.Parser b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(U)><C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fFunctorParser2
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Parser.Parser a>_R
                 ->_R Sym (Parser.N:Parser[0] <b>_R)) -}
948d49e54bee281d889cfa5822c93c4c
  $fMonadParser :: GHC.Base.Monad Parser.Parser
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Parser.Parser
                  Parser.$fApplicativeParser
                  Parser.$fMonadParser_$c>>=
                  Parser.$fMonadParser_$c>>
                  Parser.$fApplicativeParser_$cpure
                  Parser.$fMonadParser_$s$dmfail -}
948d49e54bee281d889cfa5822c93c4c
  $fMonadParser1 ::
    Parser.Parser a
    -> (a -> Parser.Parser b)
    -> GHC.Base.String
    -> [(b, GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,C(U)><L,U>,
     Unfolding: (\ @ a
                   @ b
                   (p :: Parser.Parser a)
                   (f :: a -> Parser.Parser b)
                   (s :: GHC.Base.String) ->
                 Parser.$fMonadParser2
                   @ b
                   (Parser.$fFunctorParser2 @ a @ (Parser.Parser b) f p s)) -}
948d49e54bee281d889cfa5822c93c4c
  $fMonadParser2 ::
    [(Parser.Parser b, GHC.Base.String)] -> [(b, GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
948d49e54bee281d889cfa5822c93c4c
  $fMonadParser_$c>> ::
    Parser.Parser a -> Parser.Parser b -> Parser.Parser b
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a
                   @ b
                   (m1 :: Parser.Parser a)
                   (k :: Parser.Parser b)
                   (eta :: GHC.Base.String) ->
                 (Parser.$fMonadParser_$c>>= @ a @ b m1 (\ (ds :: a) -> k))
                   `cast`
                 (Parser.N:Parser[0] <b>_R)
                   eta)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Parser.Parser a>_R
                 ->_R <Parser.Parser b>_R
                 ->_R Sym (Parser.N:Parser[0] <b>_R)) -}
948d49e54bee281d889cfa5822c93c4c
  $fMonadParser_$c>>= ::
    Parser.Parser a -> (a -> Parser.Parser b) -> Parser.Parser b
  {- Arity: 3, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,C(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Parser.$fMonadParser1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Parser.Parser a>_R
                 ->_R <a -> Parser.Parser b>_R
                 ->_R Sym (Parser.N:Parser[0] <b>_R)) -}
948d49e54bee281d889cfa5822c93c4c
  $fMonadParser_$s$dmfail :: GHC.Base.String -> Parser.Parser a
  {- Arity: 1, Strictness: <B,U>x,
     Unfolding: InlineRule (-1, True, True)
                (\ @ a (s :: GHC.Base.String) ->
                 GHC.Err.errorWithoutStackTrace
                   @ 'GHC.Types.PtrRepLifted
                   @ (Parser.Parser a)
                   s) -}
6b48e7e122fef976aef0be2b248b748d
  $tc'P :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12280288318743715398##
                   2071794700164827551##
                   Parser.$trModule
                   Parser.$tc'P1) -}
c73299e5e8454d92ee2ca9931474d099
  $tc'P1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'P"#) -}
8be596e3ca7f88c963c5f28e668db643
  $tcParser :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11466595461941583302##
                   8292753142028545893##
                   Parser.$trModule
                   Parser.$trModule1) -}
b1e9b3a97a6f197f05609731bde42a73
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Parser.$trModule2
                   Parser.$trModule1) -}
ba4988c33e826b0eb8a363451dfe5ba0
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Parser"#) -}
60e0200529cbd9e8ca9fa33434bc90da
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "ht-extension-organizer-0.1.0.0-y3uypH7gCtA60AaWeuyZL"#) -}
14eaa600d3930706fc5952c89cb5c406
  $wtimes ::
    GHC.Prim.Int#
    -> Parser.Parser a -> GHC.Base.String -> [([a], GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,C(U)><L,U>,
     Inline: [0] -}
948d49e54bee281d889cfa5822c93c4c
  newtype Parser a = P (GHC.Base.String -> [(a, GHC.Base.String)])
34b8ea8fc2af650ad24a0e006ec36cf6
  char :: GHC.Types.Char -> Parser.Parser GHC.Types.Char
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Parser.char1
                  `cast`
                (<GHC.Types.Char>_R
                 ->_R Sym (Parser.N:Parser[0] <GHC.Types.Char>_R)) -}
2ead83904c47a1fa47c8804a3e59d4b3
  char1 ::
    GHC.Types.Char
    -> GHC.Base.String -> [(GHC.Types.Char, GHC.Base.String)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (c :: GHC.Types.Char) (s :: GHC.Base.String) ->
                 case s of wild {
                   [] -> GHC.Types.[] @ (GHC.Types.Char, GHC.Base.String)
                   : x xs
                   -> case x of wild1 { GHC.Types.C# x1 ->
                      case c of wild2 { GHC.Types.C# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.eqChar# x1 y) of wild3 {
                        GHC.Types.False -> GHC.Types.[] @ (GHC.Types.Char, GHC.Base.String)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ (GHC.Types.Char, GHC.Base.String)
                             (wild1, xs)
                             (GHC.Types.[] @ (GHC.Types.Char, GHC.Base.String)) } } } }) -}
841bdf90e74e34026ad26296bf5c7cef
  decimal :: Parser.Parser GHC.Types.Int
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Parser.decimal1
                  `cast`
                (Sym (Parser.N:Parser[0] <GHC.Types.Int>_R)) -}
4b919f7eb41c8dbea54c5bc1487f74bd
  decimal1 :: GHC.Base.String -> [(GHC.Types.Int, GHC.Base.String)]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 Parser.decimal_go
                   (Parser.$fAlternativeParser2
                      @ GHC.Types.Int
                      Parser.decimal2 `cast` (Sym (Parser.N:Parser[0] <GHC.Types.Int>_R))
                      s)) -}
b60e0c26f739c886c0bfcbe5aa1cce9c
  decimal2 :: GHC.Base.String -> [(GHC.Types.Int, GHC.Base.String)]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 case s of wild {
                   [] -> GHC.Types.[] @ (GHC.Types.Int, GHC.Base.String)
                   : x xs
                   -> case x of wild1 { GHC.Types.C# c# ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.leWord#
                                (GHC.Prim.int2Word# (GHC.Prim.-# (GHC.Prim.ord# c#) 48#))
                                9##) of wild2 {
                        GHC.Types.False -> GHC.Types.[] @ (GHC.Types.Int, GHC.Base.String)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ (GHC.Types.Int, GHC.Base.String)
                             (case Data.Char.$wdigitToInt c# of ww2 { DEFAULT ->
                              GHC.Types.I# ww2 },
                              xs)
                             (GHC.Types.[] @ (GHC.Types.Int, GHC.Base.String)) } } }) -}
f23fc83b5f0919cca35d3829473d0a31
  decimal_go ::
    [([GHC.Types.Int], GHC.Base.String)]
    -> [(GHC.Types.Int, GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b38ab0b187eb96660c4bfd8727401c76
  digit :: Parser.Parser GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Parser.decimal2
                  `cast`
                (Sym (Parser.N:Parser[0] <GHC.Types.Int>_R)) -}
e1752a18f6360aba15efb727380cbcaf
  endParsing :: Parser.Parser ()
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m2,
     Unfolding: InlineRule (0, True, True)
                Parser.endParsing1 `cast` (Sym (Parser.N:Parser[0] <()>_R)) -}
6c5121ebf07e3dd9598bb12eaf176ea8
  endParsing1 :: GHC.Base.String -> [((), [GHC.Types.Char])]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m2,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: GHC.Base.String) -> Parser.endParsing_x) -}
d8a6db5d2a8c08290b7eedbbff05e788
  endParsing2 :: ((), [GHC.Types.Char])
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((GHC.Tuple.(), GHC.Types.[] @ GHC.Types.Char)) -}
d5693208205862b026c5d8674f5cbf30
  endParsing_x :: [((), [GHC.Types.Char])]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ ((), [GHC.Types.Char])
                   Parser.endParsing2
                   (GHC.Types.[] @ ((), [GHC.Types.Char]))) -}
6fe4982cc029cfa95a9f525cac3a8721
  matches ::
    (GHC.Types.Char -> GHC.Types.Bool) -> Parser.Parser GHC.Types.Char
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Parser.matches1
                  `cast`
                (<GHC.Types.Char -> GHC.Types.Bool>_R
                 ->_R Sym (Parser.N:Parser[0] <GHC.Types.Char>_R)) -}
9caf95399c89ac5357548c41a4a66fd8
  matches1 ::
    (GHC.Types.Char -> GHC.Types.Bool)
    -> GHC.Base.String -> [(GHC.Types.Char, GHC.Base.String)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (p :: GHC.Types.Char -> GHC.Types.Bool)
                   (s :: GHC.Base.String) ->
                 case s of wild {
                   [] -> GHC.Types.[] @ (GHC.Types.Char, GHC.Base.String)
                   : x xs
                   -> case p x of wild1 {
                        GHC.Types.False -> GHC.Types.[] @ (GHC.Types.Char, GHC.Base.String)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ (GHC.Types.Char, GHC.Base.String)
                             (x, xs)
                             (GHC.Types.[] @ (GHC.Types.Char, GHC.Base.String)) } }) -}
a233f90c0c72da04ef72415d13a453dc
  runParser :: Parser.Parser a -> GHC.Base.String -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: (\ @ a (ds :: Parser.Parser a) (s :: GHC.Base.String) ->
                 case GHC.List.dropWhile
                        @ (a, [GHC.Types.Char])
                        (Parser.runParser1 @ a)
                        (ds `cast` (Parser.N:Parser[0] <a>_R) s) of wild {
                   [] -> GHC.Base.Nothing @ a
                   : ds1 ds2
                   -> case ds1 of wild1 { (,) x ds3 ->
                      case ds3 of wild2 {
                        [] -> GHC.Base.Just @ a x
                        : ipv ipv1 -> GHC.Base.Nothing @ a } } }) -}
10e5b55e3649d294c14acab2baedd3cb
  runParser1 :: (a, [GHC.Types.Char]) -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: (a, [GHC.Types.Char])) ->
                 case ds of wild { (,) x s ->
                 case s of wild1 {
                   [] -> GHC.Types.False : ds1 ds2 -> GHC.Types.True } }) -}
c1eb2621d04a74a17fde9291250e4bdb
  string :: Parser.Parser GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Parser.string1
                  `cast`
                (Sym (Parser.N:Parser[0] <[GHC.Types.Char]>_R)) -}
c0534db51e22928bc6d444e874b57c81
  string1 :: GHC.Base.String -> [([GHC.Types.Char], GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (eta :: GHC.Base.String) ->
                 case eta of wild {
                   [] -> GHC.Types.[] @ ([GHC.Types.Char], GHC.Base.String)
                   : x xs
                   -> case x of wild1 { GHC.Types.C# x1 ->
                      case x1 of wild2 {
                        DEFAULT -> GHC.Types.[] @ ([GHC.Types.Char], GHC.Base.String)
                        '"'#
                        -> Parser.string_go2
                             (Parser.string_go1
                                (Parser.string_go
                                   (Parser.$fAlternativeParser1
                                      @ GHC.Types.Char
                                      Parser.string2
                                        `cast`
                                      (Sym (Parser.N:Parser[0] <GHC.Types.Char>_R))
                                      xs))) } } }) -}
63acf033894fbf9eadef110f5f9e8cdc
  string2 :: GHC.Base.String -> [(GHC.Types.Char, GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (s :: GHC.Base.String) ->
                 case s of wild {
                   [] -> GHC.Types.[] @ (GHC.Types.Char, GHC.Base.String)
                   : x xs
                   -> case x of wild1 { GHC.Types.C# x1 ->
                      case x1 of wild2 {
                        DEFAULT
                        -> GHC.Types.:
                             @ (GHC.Types.Char, GHC.Base.String)
                             (wild1, xs)
                             (GHC.Types.[] @ (GHC.Types.Char, GHC.Base.String))
                        '"'# -> GHC.Types.[] @ (GHC.Types.Char, GHC.Base.String) } } }) -}
7a277892110b74f5db059a240e9058a5
  string_go ::
    [([GHC.Types.Char], GHC.Base.String)]
    -> [([GHC.Types.Char], GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
437c88459e83fdb9c7771b451939b3ad
  string_go1 ::
    [([GHC.Types.Char], GHC.Base.String)]
    -> [(GHC.Types.Char -> [GHC.Types.Char], GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
3f6c965f8192f70acba259f89f48c547
  string_go2 ::
    [(GHC.Types.Char -> [GHC.Types.Char], GHC.Base.String)]
    -> [([GHC.Types.Char], GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
07e3478d3e7a704bf30bedd333c57600
  times :: GHC.Types.Int -> Parser.Parser a -> Parser.Parser [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,C(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Parser.times1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Types.Int>_R
                 ->_R <Parser.Parser a>_R
                 ->_R Sym (Parser.N:Parser[0] <[a]>_R)) -}
dcd44fdb2fd7a94b202ccb61524c0d0c
  times1 ::
    GHC.Types.Int
    -> Parser.Parser a -> GHC.Base.String -> [([a], GHC.Base.String)]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U)><L,C(U)><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Types.Int)
                   (w1 :: Parser.Parser a)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Parser.$wtimes @ a ww1 w1 w2 }) -}
71b0691dce4a0dbde9b42d8628bbe23d
  token :: GHC.Base.String -> Parser.Parser GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Parser.token1
                  `cast`
                (<[GHC.Types.Char]>_R
                 ->_R Sym (Parser.N:Parser[0] <GHC.Base.String>_R)) -}
1620af66fb4a7caf108bcd722d680fac
  token1 ::
    [GHC.Types.Char]
    -> GHC.Base.String -> [(GHC.Base.String, GHC.Base.String)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
60acfa458952ed56b17b37fdfa3f3e12
  whitespace :: Parser.Parser GHC.Base.String
  {- Arity: 1, HasNoCafRefs,
     Unfolding: InlineRule (0, True, True)
                Parser.whitespace1
                  `cast`
                (Sym (Parser.N:Parser[0] <[GHC.Types.Char]>_R)) -}
ed54574af9a8410ae531ce28ffcb29a5
  whitespace1 ::
    GHC.Base.String -> [([GHC.Types.Char], GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (Parser.$fAlternativeParser1
                   @ GHC.Types.Char
                   Parser.whitespace2
                     `cast`
                   (Sym (Parser.N:Parser[0] <GHC.Types.Char>_R))) -}
1fdbbd4d47f0731743fd9879fe271f1d
  whitespace2 ::
    GHC.Base.String -> [(GHC.Types.Char, GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 case s of wild {
                   [] -> GHC.Types.[] @ (GHC.Types.Char, GHC.Base.String)
                   : x xs
                   -> case x of ww { GHC.Types.C# ww1 ->
                      let {
                        x1 :: GHC.Prim.Word# = GHC.Prim.int2Word# (GHC.Prim.ord# ww1)
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.leWord# x1 887##) of wild1 {
                        GHC.Types.False
                        -> case {__pkg_ccall base-4.9.1.0 u_iswspace GHC.Prim.Int#
                                                                     -> GHC.Prim.State#
                                                                          GHC.Prim.RealWorld
                                                                     -> (# GHC.Prim.State#
                                                                             GHC.Prim.RealWorld,
                                                                           GHC.Prim.Int# #)}
                                  (GHC.Prim.ord# ww1)
                                  GHC.Prim.realWorld# of wild2 { (#,#) ds ds1 ->
                           case ds1 of wild3 {
                             DEFAULT
                             -> GHC.Types.:
                                  @ (GHC.Types.Char, GHC.Base.String)
                                  (ww, xs)
                                  (GHC.Types.[] @ (GHC.Types.Char, GHC.Base.String))
                             0# -> GHC.Types.[] @ (GHC.Types.Char, GHC.Base.String) } }
                        GHC.Types.True
                        -> case x1 of wild2 {
                             DEFAULT
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.leWord#
                                          (GHC.Prim.minusWord# wild2 9##)
                                          4##) of wild3 {
                                  GHC.Types.False
                                  -> case wild2 of wild4 {
                                       DEFAULT -> GHC.Types.[] @ (GHC.Types.Char, GHC.Base.String)
                                       160##
                                       -> GHC.Types.:
                                            @ (GHC.Types.Char, GHC.Base.String)
                                            (ww, xs)
                                            (GHC.Types.[] @ (GHC.Types.Char, GHC.Base.String)) }
                                  GHC.Types.True
                                  -> GHC.Types.:
                                       @ (GHC.Types.Char, GHC.Base.String)
                                       (ww, xs)
                                       (GHC.Types.[] @ (GHC.Types.Char, GHC.Base.String)) }
                             32##
                             -> GHC.Types.:
                                  @ (GHC.Types.Char, GHC.Base.String)
                                  (ww, xs)
                                  (GHC.Types.[] @ (GHC.Types.Char, GHC.Base.String)) } } } }) -}
instance [safe] GHC.Base.Alternative [Parser.Parser]
  = Parser.$fAlternativeParser
instance [safe] GHC.Base.Applicative [Parser.Parser]
  = Parser.$fApplicativeParser
instance [safe] GHC.Base.Functor [Parser.Parser]
  = Parser.$fFunctorParser
instance [safe] GHC.Base.Monad [Parser.Parser]
  = Parser.$fMonadParser
"SPEC/Parser $dmfail @ Parser" [ALWAYS] forall ($dMonad :: GHC.Base.Monad
                                                             Parser.Parser)
  GHC.Base.$dmfail @ Parser.Parser $dMonad
  = Parser.$fMonadParser_$s$dmfail
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

