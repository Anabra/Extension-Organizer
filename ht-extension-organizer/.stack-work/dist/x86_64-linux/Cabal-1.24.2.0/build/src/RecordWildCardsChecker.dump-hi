
==================== FINAL INTERFACE ====================
2017-09-03 23:39:03.63147 UTC

interface ht-extension-organizer-0.1.0.0-1NgBbe619AH4JExLErEUCI:RecordWildCardsChecker 8002
  interface hash: df8fe73901fb45cd85751c950ad947bb
  ABI hash: 12f3b9bedb54acbffe9e9f963498b748
  export-list hash: 9eefb0279d08d0f59521eb14428b9b37
  orphan hash: e03d401bba0e5423febf37ed3c70c808
  flag hash: 3765faaf2f7c34423ae2f3781e67b8fa
  sig of: Nothing
  used TH splices: False
  where
exports:
  RecordWildCardsChecker.chkRecordWildCards
  RecordWildCardsChecker.chkRecordWildCardsExpr
  RecordWildCardsChecker.chkRecordWildCardsPat
module dependencies: ExtMonad
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 directory-1.3.0.0@directory-1.3.0.0
                      either-4.4.1.1@either-4.4.1.1-6PiwKYkn4v6B4KO2R2Fu1b
                      filepath-1.4.1.1@filepath-1.4.1.1 ghc-8.0.2
                      ghc-boot-8.0.2@ghc-boot-8.0.2 ghc-boot-th-8.0.2@ghc-boot-th-8.0.2
                      ghc-paths-0.1.0.9@ghc-paths-0.1.0.9-AhaDlGOsRAepox069XzG
                      ghc-prim-0.5.0.0 ghci-8.0.2@ghci-8.0.2
                      hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol
                      haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6
                      haskell-tools-backend-ghc-0.8.1.0@haskell-tools-backend-ghc-0.8.1.0-DqHnbK8OPi6CBD5cIPITWq
                      haskell-tools-prettyprint-0.8.1.0@haskell-tools-prettyprint-0.8.1.0-F9iWkGq5ppnLH6whHm0DlC
                      haskell-tools-refactor-0.8.1.0@haskell-tools-refactor-0.8.1.0-AF8Q4cA8mAnLNwu5t0Icw8
                      haskell-tools-rewrite-0.8.1.0@haskell-tools-rewrite-0.8.1.0-85A6q9dMQgvKEKG9I8fxVU
                      hoopl-3.10.2.1@hoopl-3.10.2.1 hpc-0.6.0.3@hpc-0.6.0.3
                      instance-control-0.1.1.1@instance-control-0.1.1.1-1defRS82vAAEmZKRhe67aa
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      pretty-1.1.3.3@pretty-1.1.3.3 process-1.4.3.0@process-1.4.3.0
                      references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo
                      safe-0.3.15@safe-0.3.15-2Yd45VWFfdcKqKyispOifY
                      split-0.2.3.2@split-0.2.3.2-CJl40zTyCIV16Pr60nb7CT
                      syb-0.7@syb-0.7-4OKdCpwGutyB1rNRmoa0ya template-haskell-2.11.1.0
                      text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00
                      time-1.6.0.1@time-1.6.0.1 transformers-0.5.2.0@transformers-0.5.2.0
                      uniplate-1.6.12@uniplate-1.6.12-4PyZX21trQJ5lfk0CDvC7U
                      unix-2.7.2.1@unix-2.7.2.1
                      unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         ghc-8.0.2:BlockId ghc-8.0.2:DsMonad ghc-8.0.2:LoadIface
         ghc-8.0.2:PPC.Ppr ghc-8.0.2:PprCmm ghc-8.0.2:PprCmmDecl
         ghc-8.0.2:PprCmmExpr ghc-8.0.2:PprCore ghc-8.0.2:SPARC.Ppr
         ghc-8.0.2:TcEnv ghc-8.0.2:TcRnMonad ghc-8.0.2:X86.Ppr
         ghc-boot-8.0.2@ghc-boot-8.0.2:GHC.LanguageExtensions
         ghci-8.0.2@ghci-8.0.2:GHCi.Message
         ghci-8.0.2@ghci-8.0.2:GHCi.TH.Binary
         hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol:Data.Hashable.Generic
         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Instances.Data
         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Instances.Eq
         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Instances.Generic
         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Instances.SemanticTraversal
         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Instances.Show
         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Instances.SourceInfoTraversal
         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.SemaInfoTypes
         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Utils.GHCInstances
         haskell-tools-backend-ghc-0.8.1.0@haskell-tools-backend-ghc-0.8.1.0-DqHnbK8OPi6CBD5cIPITWq:Language.Haskell.Tools.AST.FromGHC.Utils
         haskell-tools-prettyprint-0.8.1.0@haskell-tools-prettyprint-0.8.1.0-F9iWkGq5ppnLH6whHm0DlC:Language.Haskell.Tools.Transform.RangeTemplate
         haskell-tools-prettyprint-0.8.1.0@haskell-tools-prettyprint-0.8.1.0-F9iWkGq5ppnLH6whHm0DlC:Language.Haskell.Tools.Transform.SourceTemplate
         haskell-tools-prettyprint-0.8.1.0@haskell-tools-prettyprint-0.8.1.0-F9iWkGq5ppnLH6whHm0DlC:Language.Haskell.Tools.Transform.SourceTemplateHelpers
         haskell-tools-refactor-0.8.1.0@haskell-tools-refactor-0.8.1.0-AF8Q4cA8mAnLNwu5t0Icw8:Language.Haskell.Tools.Refactor.RefactorBase
         ht-extension-organizer-0.1.0.0-1NgBbe619AH4JExLErEUCI:ExtMonad
         references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo:Control.Reference.Predefined.Containers.Tree
         references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo:Control.Reference.TH.Records
         syb-0.7@syb-0.7-4OKdCpwGutyB1rNRmoa0ya:Data.Generics.Instances
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Show
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
         uniplate-1.6.12@uniplate-1.6.12-4PyZX21trQJ5lfk0CDvC7U:Data.Generics.Uniplate.Data
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Compose base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         ghc-8.0.2:PlaceHolder ghc-8.0.2:TrieMap
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         ghci-8.0.2@ghci-8.0.2:GHCi.FFI ghci-8.0.2@ghci-8.0.2:GHCi.Message
                         ghci-8.0.2@ghci-8.0.2:GHCi.ResolvedBCO
                         ghci-8.0.2@ghci-8.0.2:SizedSeq
                         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Ann
                         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Instances.Generic
                         haskell-tools-prettyprint-0.8.1.0@haskell-tools-prettyprint-0.8.1.0-F9iWkGq5ppnLH6whHm0DlC:Language.Haskell.Tools.Transform.RangeTemplate
                         haskell-tools-prettyprint-0.8.1.0@haskell-tools-prettyprint-0.8.1.0-F9iWkGq5ppnLH6whHm0DlC:Language.Haskell.Tools.Transform.SourceTemplate
                         hoopl-3.10.2.1@hoopl-3.10.2.1:Compiler.Hoopl.Block
                         hoopl-3.10.2.1@hoopl-3.10.2.1:Compiler.Hoopl.Dataflow
                         hoopl-3.10.2.1@hoopl-3.10.2.1:Compiler.Hoopl.Fuel
                         hoopl-3.10.2.1@hoopl-3.10.2.1:Compiler.Hoopl.Label
                         hoopl-3.10.2.1@hoopl-3.10.2.1:Compiler.Hoopl.Unique
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo:Control.Reference.Predefined.Containers
                         references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo:Control.Reference.Predefined.Containers.Tree
                         references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo:Control.Reference.Types
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashMap.Base
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashSet
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type 92441ea50916fa3940e20fae60f255d7
import  -/  haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Helpers 686b27398ad9e18bc691422b21273fbb
import  -/  haskell-tools-refactor-0.8.1.0@haskell-tools-refactor-0.8.1.0-AF8Q4cA8mAnLNwu5t0Icw8:Language.Haskell.Tools.Refactor 84acc8d60e278de91351468f26f90e1c
import  -/  haskell-tools-rewrite-0.8.1.0@haskell-tools-rewrite-0.8.1.0-85A6q9dMQgvKEKG9I8fxVU:Language.Haskell.Tools.AST.ElementTypes df954b524d036aee274d8ad0f571417a
import  -/  haskell-tools-rewrite-0.8.1.0@haskell-tools-rewrite-0.8.1.0-85A6q9dMQgvKEKG9I8fxVU:Language.Haskell.Tools.AST.Match.Exprs 40e6739cc8a80bd68ce2dee2765b9b5e
import  -/  haskell-tools-rewrite-0.8.1.0@haskell-tools-rewrite-0.8.1.0-85A6q9dMQgvKEKG9I8fxVU:Language.Haskell.Tools.AST.Match.Patterns 2fd4c4dbea6a0193d161dd2ecdde7cd7
import  -/  ExtMonad 6efef839e8084e4944c989299f7e8b99
  exports: 78fe3d4ca4f10930e37e7961f002463e
  ExtMonad 9082366c14e6863467573cd95104adfa
  addOccurenceM 8a455580ad51ae9a9f7b605e075194b3
import  -/  references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo:Control.Reference d89ee82346f6e25c55a8a19dbf84658e
import  -/  references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo:Control.Reference.Operators 55e717f4df077a71cb70a96f85f6a393
b085131bb82f67e508fd419bc97c2083
  $s$fApplicativeStateT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc)
                  (RecordWildCardsChecker.$s$fApplicativeStateT_$s$fApplicativeStateT_$cp1Applicative
                     @ s)
                  (RecordWildCardsChecker.$s$fApplicativeStateT_$s$fApplicativeStateT_$cpure
                     @ s)
                  (RecordWildCardsChecker.$s$fApplicativeStateT_$s$fApplicativeStateT_$c<*>
                     @ s)
                  (Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c*>
                     @ GhcMonad.Ghc
                     @ s
                     RecordWildCardsChecker.$s$fApplicativeStateT_$dFunctor
                     GhcMonad.$fMonadGhc)
                  (Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c<*
                     @ GhcMonad.Ghc
                     @ s
                     RecordWildCardsChecker.$s$fApplicativeStateT_$dFunctor
                     GhcMonad.$fMonadGhc) -}
846ab7674cf8a9da9d270d8f00785914
  $s$fApplicativeStateT_$dFunctor :: GHC.Base.Functor GhcMonad.Ghc
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) GhcMonad.$fFunctorGhc -}
28532de90fe3aafbeb14be947e762ae2
  $s$fApplicativeStateT_$s$fApplicativeStateT_$c<*> ::
    Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a
    -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,C(C1(C1(U(U,U(1*U,1*U)))))><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (ds2 :: Control.Monad.Trans.State.Lazy.StateT
                             s GhcMonad.Ghc (a -> b))
                   (ds3 :: Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> GhcMonad.Ghc (b, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b)
                   (\ (tpl :: s -> GhcMonad.Ghc (b, s)) -> tpl)
                     `cast`
                   (<s -> GhcMonad.Ghc (b, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <GhcMonad.Ghc>_R <b>_N))
                   (\ (s1 :: s) ->
                    GhcMonad.$fMonadGhc_$c>>=
                      @ (a -> b, s)
                      @ (b, s)
                      (ds2
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N <GhcMonad.Ghc>_R <a -> b>_N)
                         s1)
                      (\ (ds4 :: (a -> b, s)) ->
                       GhcMonad.$fMonadGhc_$c>>=
                         @ (a, s)
                         @ (b, s)
                         (ds3
                            `cast`
                          (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <GhcMonad.Ghc>_R <a>_N)
                            (case ds4 of wild { (,) f s' -> s' }))
                         (\ (ds5 :: (a, s)) ->
                          GhcMonad.$fApplicativeGhc_$cpure
                            @ (b, s)
                            (case ds4 of wild { (,) f s' ->
                             f (case ds5 of wild1 { (,) x s'' -> x }) },
                             case ds5 of wild { (,) x s'' -> s'' }))))) -}
b36effa63e4936e288f519054aeee30c
  $s$fApplicativeStateT_$s$fApplicativeStateT_$cp1Applicative ::
    GHC.Base.Functor
      (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                RecordWildCardsChecker.$s$fApplicativeStateT_$s$fFunctorStateT -}
c17967564fd71f4c51d67c7b58798355
  $s$fApplicativeStateT_$s$fApplicativeStateT_$cpure ::
    a -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,A><S,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s @ a (a1 :: a) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> GhcMonad.Ghc (a, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a)
                   (\ (tpl :: s -> GhcMonad.Ghc (a, s)) -> tpl)
                     `cast`
                   (<s -> GhcMonad.Ghc (a, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <GhcMonad.Ghc>_R <a>_N))
                   (\ (s1 :: s)
                      (eta :: GhcMonad.Session)
                      (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                    ((GhcMonad.$fApplicativeGhc_$cpure @ (a, s) (a1, s1))
                       `cast`
                     (GhcMonad.N:Ghc[0] <(a, s)>_R)
                       eta)
                      `cast`
                    (GHC.Types.N:IO[0] <(a, s)>_R)
                      eta1)
                     `cast`
                   (<s>_R
                    ->_R Trans
                             (<GhcMonad.Session>_R ->_R Sym (GHC.Types.N:IO[0] <(a, s)>_R))
                             (Sym (GhcMonad.N:Ghc[0] <(a, s)>_R)))) -}
b401f27125bf8506e856768f1922ca93
  $s$fApplicativeStateT_$s$fFunctorStateT ::
    GHC.Base.Functor
      (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc)
                  (RecordWildCardsChecker.$s$fApplicativeStateT_$s$fFunctorStateT_$cfmap
                     @ s)
                  (Control.Monad.Trans.State.Lazy.$fFunctorStateT_$c<$
                     @ GhcMonad.Ghc
                     @ s
                     GhcMonad.$fFunctorGhc) -}
43668a60e0f40fbb6b2e8ddf0fb8e847
  $s$fApplicativeStateT_$s$fFunctorStateT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a
    -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(U)><L,1*C1(U)><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (f :: a -> b)
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> GhcMonad.Ghc (b, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b)
                   (\ (tpl :: s -> GhcMonad.Ghc (b, s)) -> tpl)
                     `cast`
                   (<s -> GhcMonad.Ghc (b, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <GhcMonad.Ghc>_R <b>_N))
                   (\ (s1 :: s) ->
                    GHC.Base.$
                      @ 'GHC.Types.PtrRepLifted
                      @ (GhcMonad.Ghc (a, s))
                      @ (GhcMonad.Ghc (b, s))
                      (GhcMonad.$fFunctorGhc_$cfmap
                         @ (a, s)
                         @ (b, s)
                         (\ (ds2 :: (a, s)) ->
                          (f (case ds2 of wild { (,) a1 s' -> a1 }),
                           case ds2 of wild { (,) a1 s' -> s' })))
                      (Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ GhcMonad.Ghc
                         @ a
                         m1
                         s1))) -}
cbeb8ac13254cf0849284df39a6029fc
  $s$fHasRangeAnn ::
    Language.Haskell.Tools.AST.Ann.HasRange
      (Language.Haskell.Tools.AST.Ann.Ann
         elem dom Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (elem :: GHC.Types.*
                                 -> GHC.Types.* -> GHC.Types.*)
                      @ dom.
                  @ (Language.Haskell.Tools.AST.Ann.Ann
                       elem dom Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                  (RecordWildCardsChecker.$s$fHasRangeAnn_$s$fHasRangeAnn_$cgetRange
                     @ elem
                     @ dom)
                  (Language.Haskell.Tools.AST.Ann.$fHasRangeAnn_$csetRange
                     @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                     @ elem
                     @ dom
                     Language.Haskell.Tools.Transform.SourceTemplate.$fSourceInfoSrcTemplateStage) -}
6858c4e7e04e6aff0ee384135b56f802
  $s$fHasRangeAnn_$s$fHasRangeAnn_$cgetRange ::
    Language.Haskell.Tools.AST.Ann.Ann
      elem dom Language.Haskell.Tools.AST.Ann.SrcTemplateStage
    -> SrcLoc.SrcSpan
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LS(SLLL))L),1*U(1*U(A,1*U(1*U,A,A,A)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (elem :: GHC.Types.* -> GHC.Types.* -> GHC.Types.*)
                   @ dom
                   (eta :: Language.Haskell.Tools.AST.Ann.Ann
                             elem dom Language.Haskell.Tools.AST.Ann.SrcTemplateStage) ->
                 case eta of wild { Language.Haskell.Tools.AST.Ann.Ann a ds2 ->
                 case a of wild1 { Language.Haskell.Tools.AST.Ann.NodeInfo ds3 ds4 ->
                 Language.Haskell.Tools.Transform.SourceTemplate._sourceTemplateNodeRange
                   ds4 } }) -}
cce35aa4c3765cf5f2fb74af218b7414
  $s$fMonadStateT ::
    GHC.Base.Monad
      (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc)
                  (RecordWildCardsChecker.$s$fMonadStateT_$s$fMonadStateT_$cp1Monad
                     @ s)
                  (RecordWildCardsChecker.$s$fMonadStateT_$s$fMonadStateT_$c>>= @ s)
                  (RecordWildCardsChecker.$s$fMonadStateT_$s$fMonadStateT_$c>> @ s)
                  (Control.Monad.Trans.State.Lazy.$fMonadStateT_$creturn
                     @ GhcMonad.Ghc
                     @ s
                     GhcMonad.$fMonadGhc)
                  (RecordWildCardsChecker.$s$fMonadStateT_$s$fMonadStateT_$cfail
                     @ s) -}
6eae6a4fbde3177501c476cdede976cc
  $s$fMonadStateT_$s$fMonadStateT_$c>> ::
    Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a
    -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b
    -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,C(C1(C1(U)))><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> GhcMonad.Ghc (b, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b)
                   (\ (tpl :: s -> GhcMonad.Ghc (b, s)) -> tpl)
                     `cast`
                   (<s -> GhcMonad.Ghc (b, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <GhcMonad.Ghc>_R <b>_N))
                   (\ (s1 :: s) ->
                    GhcMonad.$fMonadGhc_$c>>=
                      @ (a, s)
                      @ (b, s)
                      (Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ GhcMonad.Ghc
                         @ a
                         m1
                         s1)
                      (\ (ds2 :: (a, s)) ->
                       Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ GhcMonad.Ghc
                         @ b
                         k
                         (case ds2 of wild { (,) a1 s' -> s' })))) -}
046ed5040a040680184de85b0b5a54e2
  $s$fMonadStateT_$s$fMonadStateT_$c>>= ::
    Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a
    -> (a -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b)
    -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,C(C1(C1(C1(U))))><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a)
                   (k :: a
                         -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> GhcMonad.Ghc (b, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b)
                   (\ (tpl :: s -> GhcMonad.Ghc (b, s)) -> tpl)
                     `cast`
                   (<s -> GhcMonad.Ghc (b, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <GhcMonad.Ghc>_R <b>_N))
                   (\ (s1 :: s) ->
                    GhcMonad.$fMonadGhc_$c>>=
                      @ (a, s)
                      @ (b, s)
                      (Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ GhcMonad.Ghc
                         @ a
                         m1
                         s1)
                      (\ (ds2 :: (a, s)) ->
                       Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ GhcMonad.Ghc
                         @ b
                         (k (case ds2 of wild { (,) a1 s' -> a1 }))
                         (case ds2 of wild { (,) a1 s' -> s' })))) -}
08488eaa9bd4b8d0d5697f97fc7225cb
  $s$fMonadStateT_$s$fMonadStateT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a
  {- Arity: 2, Strictness: <B,U><B,A>x, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s @ a (str :: GHC.Base.String) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> GhcMonad.Ghc (a, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a)
                   (\ (tpl :: s -> GhcMonad.Ghc (a, s)) -> tpl)
                     `cast`
                   (<s -> GhcMonad.Ghc (a, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <GhcMonad.Ghc>_R <a>_N))
                   (\ (ds2 :: s) -> GhcMonad.$fMonadGhc_$s$dmfail @ (a, s) str)) -}
f4f456adac51027d1cc84c07a2e327a4
  $s$fMonadStateT_$s$fMonadStateT_$cp1Monad ::
    GHC.Base.Applicative
      (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                RecordWildCardsChecker.$s$fApplicativeStateT -}
7ea31df251bd8635d9d2b2388da3799b
  $s$fRefMonadswr ::
    Control.Reference.Representation.RefMonads
      (Control.Monad.Trans.State.Lazy.StateT
         (Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
         GhcMonad.Ghc)
      Data.Proxy.Proxy
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       (Data.Map.Base.Map
                          GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
                       GhcMonad.Ghc)
                  @ Data.Proxy.Proxy
                  RecordWildCardsChecker.$s$fRefMonadswr3
                  RecordWildCardsChecker.$s$fRefMonadswr2
                  RecordWildCardsChecker.$s$fRefMonadswr1
                  RecordWildCardsChecker.$s$fRefMonadswr_$s$fRefMonadswr_$cp4RefMonads
                  RecordWildCardsChecker.$s$fRefMonadswr_$s$fRefMonadswr_$cp5RefMonads
                  RecordWildCardsChecker.$s$fRefMonadswr_$s$fRefMonadswr_$cp6RefMonads -}
5a66a444da336dd2be69c807491992cc
  $s$fRefMonadswr1 ::
    GHC.Base.Monad
      (Control.Monad.Trans.State.Lazy.StateT
         (Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
         GhcMonad.Ghc)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (RecordWildCardsChecker.$s$fMonadStateT
                   @ (Data.Map.Base.Map
                        GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])) -}
8836d57a7338f18bc3ccf50c4c79ebfe
  $s$fRefMonadswr2 ::
    GHC.Base.Applicative
      (Control.Monad.Trans.State.Lazy.StateT
         (Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
         GhcMonad.Ghc)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (RecordWildCardsChecker.$s$fApplicativeStateT
                   @ (Data.Map.Base.Map
                        GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])) -}
0a36f0c9a4aed5c00f9489f0e8cc166b
  $s$fRefMonadswr3 ::
    GHC.Base.Functor
      (Control.Monad.Trans.State.Lazy.StateT
         (Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
         GhcMonad.Ghc)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (RecordWildCardsChecker.$s$fApplicativeStateT_$s$fFunctorStateT
                   @ (Data.Map.Base.Map
                        GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])) -}
2fd7bcf94dc38861b925e9e9c2ee2ac3
  $s$fRefMonadswr_$s$fRefMonadswr_$cp4RefMonads ::
    GHC.Base.Functor Data.Proxy.Proxy
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) Data.Proxy.$fFunctorProxy -}
771357d098adb713286513809d102999
  $s$fRefMonadswr_$s$fRefMonadswr_$cp5RefMonads ::
    GHC.Base.Applicative Data.Proxy.Proxy
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Data.Proxy.$fApplicativeProxy -}
dbacb02571e67e8ad33cd1b68b382f48
  $s$fRefMonadswr_$s$fRefMonadswr_$cp6RefMonads ::
    GHC.Base.Monad Data.Proxy.Proxy
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) Data.Proxy.$fMonadProxy -}
f4f94ac1567cbd0f3034e63c38623ccd
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   RecordWildCardsChecker.$trModule2
                   RecordWildCardsChecker.$trModule1) -}
0b13801de9dc8a6c7ac8d8e37311d4fd
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "RecordWildCardsChecker"#) -}
c6b6b323ea0841cbb514c9a8db610a07
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "ht-extension-organizer-0.1.0.0-1NgBbe619AH4JExLErEUCI"#) -}
7f0ac21cbba55c2d91cfe0d782d9306f
  $wchkRecordWildCardsExpr ::
    Language.Haskell.Tools.AST.Ann.NodeInfo
      (Language.Haskell.Tools.AST.Ann.SemanticInfo
         dom Language.Haskell.Tools.AST.Representation.Exprs.UFieldUpdate)
      (Language.Haskell.Tools.AST.Ann.SpanInfo
         Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
    -> Language.Haskell.Tools.AST.Representation.Exprs.UFieldUpdate
         dom Language.Haskell.Tools.AST.Ann.SrcTemplateStage
    -> Data.Map.Base.Map
         GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]
    -> GhcMonad.Ghc
         (Language.Haskell.Tools.AST.ElementTypes.FieldUpdate dom,
          Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
  {- Arity: 3, Strictness: <L,U><S,U><L,U>, Inline: [0],
     Unfolding: (\ @ dom
                   (ww :: Language.Haskell.Tools.AST.Ann.NodeInfo
                            (Language.Haskell.Tools.AST.Ann.SemanticInfo
                               dom Language.Haskell.Tools.AST.Representation.Exprs.UFieldUpdate)
                            (Language.Haskell.Tools.AST.Ann.SpanInfo
                               Language.Haskell.Tools.AST.Ann.SrcTemplateStage))
                   (ww1 :: Language.Haskell.Tools.AST.Representation.Exprs.UFieldUpdate
                             dom Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                   (w :: Data.Map.Base.Map
                           GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]) ->
                 let {
                   wild :: Language.Haskell.Tools.AST.ElementTypes.FieldUpdate dom
                   = Language.Haskell.Tools.AST.Ann.Ann
                       @ Language.Haskell.Tools.AST.Representation.Exprs.UFieldUpdate
                       @ dom
                       @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                       ww
                       ww1
                 } in
                 case ww1 of wild1 {
                   DEFAULT
                   -> let {
                        lvl8 :: (Language.Haskell.Tools.AST.ElementTypes.FieldUpdate dom,
                                 Data.Map.Base.Map
                                   GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
                        = (wild, w)
                      } in
                      (\ (eta :: GhcMonad.Session)
                         (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                       (# eta1, lvl8 #))
                        `cast`
                      (Trans
                           (<GhcMonad.Session>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <(Language.Haskell.Tools.AST.ElementTypes.FieldUpdate dom,
                                            Data.Map.Base.Map
                                              GHC.LanguageExtensions.Type.Extension
                                              [SrcLoc.SrcSpan])>_R))
                           (Sym (GhcMonad.N:Ghc[0]
                                     <(Language.Haskell.Tools.AST.ElementTypes.FieldUpdate dom,
                                       Data.Map.Base.Map
                                         GHC.LanguageExtensions.Type.Extension
                                         [SrcLoc.SrcSpan])>_R)))
                   Language.Haskell.Tools.AST.Representation.Exprs.UFieldWildcard wc
                   -> let {
                        a1 :: Data.Map.Base.Map
                                GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]
                        = Data.Map.Strict.insertWithKey
                            @ GHC.LanguageExtensions.Type.Extension
                            @ [SrcLoc.SrcSpan]
                            ExtMonad.$fOrdExtension
                            (ExtMonad.addOccurence1 @ GHC.LanguageExtensions.Type.Extension)
                            GHC.LanguageExtensions.Type.RecordWildCards
                            (GHC.Types.:
                               @ SrcLoc.SrcSpan
                               (case wc of wild2 { Language.Haskell.Tools.AST.Ann.Ann a ds2 ->
                                case a of wild3 { Language.Haskell.Tools.AST.Ann.NodeInfo ds3 ds4 ->
                                case ds4
                                       `cast`
                                     (Language.Haskell.Tools.Transform.SourceTemplate.D:R:SpanInfoSrcTemplateStage0[0]) of wild4 { Language.Haskell.Tools.Transform.SourceTemplate.SourceTemplateNode ds5 ds6 ds7 ds8 ->
                                ds5 } } })
                               (GHC.Types.[] @ SrcLoc.SrcSpan))
                            w
                      } in
                      let {
                        lvl8 :: (Language.Haskell.Tools.AST.ElementTypes.FieldUpdate dom,
                                 Data.Map.Base.Map
                                   GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
                        = (wild, a1)
                      } in
                      (\ (s :: GhcMonad.Session)
                         (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                       (# s1, lvl8 #))
                        `cast`
                      (Trans
                           (<GhcMonad.Session>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <(Language.Haskell.Tools.AST.ElementTypes.FieldUpdate dom,
                                            Data.Map.Base.Map
                                              GHC.LanguageExtensions.Type.Extension
                                              [SrcLoc.SrcSpan])>_R))
                           (Sym (GhcMonad.N:Ghc[0]
                                     <(Language.Haskell.Tools.AST.ElementTypes.FieldUpdate dom,
                                       Data.Map.Base.Map
                                         GHC.LanguageExtensions.Type.Extension
                                         [SrcLoc.SrcSpan])>_R))) }) -}
26fe1a09976f4e73970f8e2aa210e3ca
  $wchkRecordWildCardsPat ::
    Language.Haskell.Tools.AST.Ann.NodeInfo
      (Language.Haskell.Tools.AST.Ann.SemanticInfo
         dom
         Language.Haskell.Tools.AST.Representation.Patterns.UPatternField)
      (Language.Haskell.Tools.AST.Ann.SpanInfo
         Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
    -> Language.Haskell.Tools.AST.Representation.Patterns.UPatternField
         dom Language.Haskell.Tools.AST.Ann.SrcTemplateStage
    -> Data.Map.Base.Map
         GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]
    -> GhcMonad.Ghc
         (Language.Haskell.Tools.AST.ElementTypes.PatternField dom,
          Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
  {- Arity: 3, Strictness: <L,U><S,U><L,U>, Inline: [0],
     Unfolding: (\ @ dom
                   (ww :: Language.Haskell.Tools.AST.Ann.NodeInfo
                            (Language.Haskell.Tools.AST.Ann.SemanticInfo
                               dom
                               Language.Haskell.Tools.AST.Representation.Patterns.UPatternField)
                            (Language.Haskell.Tools.AST.Ann.SpanInfo
                               Language.Haskell.Tools.AST.Ann.SrcTemplateStage))
                   (ww1 :: Language.Haskell.Tools.AST.Representation.Patterns.UPatternField
                             dom Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                   (w :: Data.Map.Base.Map
                           GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]) ->
                 let {
                   wild :: Language.Haskell.Tools.AST.ElementTypes.PatternField dom
                   = Language.Haskell.Tools.AST.Ann.Ann
                       @ Language.Haskell.Tools.AST.Representation.Patterns.UPatternField
                       @ dom
                       @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                       ww
                       ww1
                 } in
                 case ww1 of wild1 {
                   DEFAULT
                   -> let {
                        lvl8 :: (Language.Haskell.Tools.AST.ElementTypes.PatternField dom,
                                 Data.Map.Base.Map
                                   GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
                        = (wild, w)
                      } in
                      (\ (eta :: GhcMonad.Session)
                         (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                       (# eta1, lvl8 #))
                        `cast`
                      (Trans
                           (<GhcMonad.Session>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <(Language.Haskell.Tools.AST.ElementTypes.PatternField
                                              dom,
                                            Data.Map.Base.Map
                                              GHC.LanguageExtensions.Type.Extension
                                              [SrcLoc.SrcSpan])>_R))
                           (Sym (GhcMonad.N:Ghc[0]
                                     <(Language.Haskell.Tools.AST.ElementTypes.PatternField dom,
                                       Data.Map.Base.Map
                                         GHC.LanguageExtensions.Type.Extension
                                         [SrcLoc.SrcSpan])>_R)))
                   Language.Haskell.Tools.AST.Representation.Patterns.UFieldWildcardPattern wildc
                   -> let {
                        a1 :: Data.Map.Base.Map
                                GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]
                        = Data.Map.Strict.insertWithKey
                            @ GHC.LanguageExtensions.Type.Extension
                            @ [SrcLoc.SrcSpan]
                            ExtMonad.$fOrdExtension
                            (ExtMonad.addOccurence1 @ GHC.LanguageExtensions.Type.Extension)
                            GHC.LanguageExtensions.Type.RecordWildCards
                            (GHC.Types.:
                               @ SrcLoc.SrcSpan
                               (case wildc of wild2 { Language.Haskell.Tools.AST.Ann.Ann a ds2 ->
                                case a of wild3 { Language.Haskell.Tools.AST.Ann.NodeInfo ds3 ds4 ->
                                case ds4
                                       `cast`
                                     (Language.Haskell.Tools.Transform.SourceTemplate.D:R:SpanInfoSrcTemplateStage0[0]) of wild4 { Language.Haskell.Tools.Transform.SourceTemplate.SourceTemplateNode ds5 ds6 ds7 ds8 ->
                                ds5 } } })
                               (GHC.Types.[] @ SrcLoc.SrcSpan))
                            w
                      } in
                      let {
                        lvl8 :: (Language.Haskell.Tools.AST.ElementTypes.PatternField dom,
                                 Data.Map.Base.Map
                                   GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
                        = (wild, a1)
                      } in
                      (\ (s :: GhcMonad.Session)
                         (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                       (# s1, lvl8 #))
                        `cast`
                      (Trans
                           (<GhcMonad.Session>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <(Language.Haskell.Tools.AST.ElementTypes.PatternField
                                              dom,
                                            Data.Map.Base.Map
                                              GHC.LanguageExtensions.Type.Extension
                                              [SrcLoc.SrcSpan])>_R))
                           (Sym (GhcMonad.N:Ghc[0]
                                     <(Language.Haskell.Tools.AST.ElementTypes.PatternField dom,
                                       Data.Map.Base.Map
                                         GHC.LanguageExtensions.Type.Extension
                                         [SrcLoc.SrcSpan])>_R))) }) -}
8d1716c00d854869a620193269d56467
  chkRecordWildCards ::
    (Language.Haskell.Tools.AST.Ann.SemanticInfo'
       dom Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls
     GHC.Prim.~# Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo,
     GHC.Show.Show
       (Language.Haskell.Tools.AST.Ann.SemanticInfo'
          dom Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls),
     GHC.Show.Show
       (Language.Haskell.Tools.AST.Ann.SemanticInfo'
          dom Language.Haskell.Tools.AST.Ann.SameInfoModuleCls),
     GHC.Show.Show
       (Language.Haskell.Tools.AST.Ann.SemanticInfo'
          dom Language.Haskell.Tools.AST.Ann.SameInfoImportCls),
     GHC.Show.Show
       (Language.Haskell.Tools.AST.Ann.SemanticInfo'
          dom Language.Haskell.Tools.AST.Ann.SameInfoExprCls),
     GHC.Show.Show
       (Language.Haskell.Tools.AST.Ann.SemanticInfo'
          dom Language.Haskell.Tools.AST.Ann.SameInfoNameCls),
     Data.Data.Data
       (node dom Language.Haskell.Tools.AST.Ann.SrcTemplateStage),
     Data.Data.Data
       (Language.Haskell.Tools.AST.Ann.SemanticInfo'
          dom Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls),
     Data.Data.Data
       (Language.Haskell.Tools.AST.Ann.SemanticInfo'
          dom Language.Haskell.Tools.AST.Ann.SameInfoModuleCls),
     Data.Data.Data
       (Language.Haskell.Tools.AST.Ann.SemanticInfo'
          dom Language.Haskell.Tools.AST.Ann.SameInfoImportCls),
     Data.Data.Data
       (Language.Haskell.Tools.AST.Ann.SemanticInfo'
          dom Language.Haskell.Tools.AST.Ann.SameInfoExprCls),
     Data.Data.Data
       (Language.Haskell.Tools.AST.Ann.SemanticInfo'
          dom Language.Haskell.Tools.AST.Ann.SameInfoNameCls),
     Data.Data.Data dom) =>
    SrcLoc.RealSrcSpan
    -> node dom Language.Haskell.Tools.AST.Ann.SrcTemplateStage
    -> Control.Monad.Trans.State.Lazy.StateT
         (Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
         GhcMonad.Ghc
         (node dom Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
  {- Arity: 13,
     Strictness: <L,U><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,1*U><L,1*U><L,1*U><L,1*U><L,1*U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
e299ff915f698971d2dd93065cf2cac5
  chkRecordWildCardsExpr ::
    Language.Haskell.Tools.AST.ElementTypes.FieldUpdate dom
    -> ExtMonad.ExtMonad
         dom (Language.Haskell.Tools.AST.ElementTypes.FieldUpdate dom)
  {- Arity: 2, Strictness: <S(LS),1*U(U,U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                RecordWildCardsChecker.chkRecordWildCardsExpr1
                  `cast`
                (forall (dom :: <GHC.Types.*>_N).
                 <Language.Haskell.Tools.AST.ElementTypes.FieldUpdate dom>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Data.Map.Base.Map
                                  GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]>_N
                               <GhcMonad.Ghc>_R
                               <Language.Haskell.Tools.AST.ElementTypes.FieldUpdate dom>_N)) -}
698183c2ee51b32daddcaa5bfbedb3cc
  chkRecordWildCardsExpr1 ::
    Language.Haskell.Tools.AST.ElementTypes.FieldUpdate dom
    -> Data.Map.Base.Map
         GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]
    -> GhcMonad.Ghc
         (Language.Haskell.Tools.AST.ElementTypes.FieldUpdate dom,
          Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
  {- Arity: 2, Strictness: <S(LS),1*U(U,U)><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ dom
                   (w :: Language.Haskell.Tools.AST.ElementTypes.FieldUpdate dom)
                   (w1 :: Data.Map.Base.Map
                            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]) ->
                 case w of ww { Language.Haskell.Tools.AST.Ann.Ann ww1 ww2 ->
                 RecordWildCardsChecker.$wchkRecordWildCardsExpr
                   @ dom
                   ww1
                   ww2
                   w1 }) -}
ed7f9ad9e5e22bae571ac8bc736c616b
  chkRecordWildCardsPat ::
    Language.Haskell.Tools.AST.ElementTypes.PatternField dom
    -> ExtMonad.ExtMonad
         dom (Language.Haskell.Tools.AST.ElementTypes.PatternField dom)
  {- Arity: 2, Strictness: <S(LS),1*U(U,U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                RecordWildCardsChecker.chkRecordWildCardsPat1
                  `cast`
                (forall (dom :: <GHC.Types.*>_N).
                 <Language.Haskell.Tools.AST.ElementTypes.PatternField dom>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Data.Map.Base.Map
                                  GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]>_N
                               <GhcMonad.Ghc>_R
                               <Language.Haskell.Tools.AST.ElementTypes.PatternField dom>_N)) -}
9224082970ffb57da0da7db22a670fb2
  chkRecordWildCardsPat1 ::
    Language.Haskell.Tools.AST.ElementTypes.PatternField dom
    -> Data.Map.Base.Map
         GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]
    -> GhcMonad.Ghc
         (Language.Haskell.Tools.AST.ElementTypes.PatternField dom,
          Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
  {- Arity: 2, Strictness: <S(LS),1*U(U,U)><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ dom
                   (w :: Language.Haskell.Tools.AST.ElementTypes.PatternField dom)
                   (w1 :: Data.Map.Base.Map
                            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]) ->
                 case w of ww { Language.Haskell.Tools.AST.Ann.Ann ww1 ww2 ->
                 RecordWildCardsChecker.$wchkRecordWildCardsPat
                   @ dom
                   ww1
                   ww2
                   w1 }) -}
"SPEC/RecordWildCardsChecker $fApplicativeStateT @ Ghc _" [ALWAYS] forall @ s
                                                                          ($dMonad :: GHC.Base.Monad
                                                                                        GhcMonad.Ghc)
                                                                          ($dFunctor :: GHC.Base.Functor
                                                                                          GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT @ GhcMonad.Ghc
                                                     @ s
                                                     $dFunctor
                                                     $dMonad
  = RecordWildCardsChecker.$s$fApplicativeStateT @ s
"SPEC/RecordWildCardsChecker $fApplicativeStateT_$c<*> @ Ghc _" [ALWAYS] forall @ s
                                                                                ($dMonad :: GHC.Base.Monad
                                                                                              GhcMonad.Ghc)
                                                                                ($dFunctor :: GHC.Base.Functor
                                                                                                GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c<*> @ GhcMonad.Ghc
                                                           @ s
                                                           $dFunctor
                                                           $dMonad
  = RecordWildCardsChecker.$s$fApplicativeStateT_$s$fApplicativeStateT_$c<*>
      @ s
"SPEC/RecordWildCardsChecker $fApplicativeStateT_$cp1Applicative @ Ghc _" [ALWAYS] forall @ s
                                                                                          ($dMonad :: GHC.Base.Monad
                                                                                                        GhcMonad.Ghc)
                                                                                          ($dFunctor :: GHC.Base.Functor
                                                                                                          GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$cp1Applicative @ GhcMonad.Ghc
                                                                     @ s
                                                                     $dFunctor
                                                                     $dMonad
  = RecordWildCardsChecker.$s$fApplicativeStateT_$s$fApplicativeStateT_$cp1Applicative
      @ s
"SPEC/RecordWildCardsChecker $fApplicativeStateT_$cpure @ Ghc _" [ALWAYS] forall @ s
                                                                                 ($dMonad :: GHC.Base.Monad
                                                                                               GhcMonad.Ghc)
                                                                                 ($dFunctor :: GHC.Base.Functor
                                                                                                 GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$cpure @ GhcMonad.Ghc
                                                            @ s
                                                            $dFunctor
                                                            $dMonad
  = RecordWildCardsChecker.$s$fApplicativeStateT_$s$fApplicativeStateT_$cpure
      @ s
"SPEC/RecordWildCardsChecker $fFunctorStateT @ Ghc _" [ALWAYS] forall @ s
                                                                      ($dFunctor :: GHC.Base.Functor
                                                                                      GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fFunctorStateT @ GhcMonad.Ghc
                                                 @ s
                                                 $dFunctor
  = RecordWildCardsChecker.$s$fApplicativeStateT_$s$fFunctorStateT
      @ s
"SPEC/RecordWildCardsChecker $fFunctorStateT_$cfmap @ Ghc _" [ALWAYS] forall @ s
                                                                             ($dFunctor :: GHC.Base.Functor
                                                                                             GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap @ GhcMonad.Ghc
                                                        @ s
                                                        $dFunctor
  = RecordWildCardsChecker.$s$fApplicativeStateT_$s$fFunctorStateT_$cfmap
      @ s
"SPEC/RecordWildCardsChecker $fHasRangeAnn @ SrcTemplateStage _ _" [ALWAYS] forall @ (elem :: GHC.Types.*
                                                                                              -> GHC.Types.*
                                                                                              -> GHC.Types.*)
                                                                                   @ dom
                                                                                   ($dSourceInfo :: Language.Haskell.Tools.AST.Ann.SourceInfo
                                                                                                      Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
  Language.Haskell.Tools.AST.Ann.$fHasRangeAnn @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                                               @ elem
                                               @ dom
                                               $dSourceInfo
  = RecordWildCardsChecker.$s$fHasRangeAnn @ elem @ dom
"SPEC/RecordWildCardsChecker $fHasRangeAnn_$cgetRange @ SrcTemplateStage _ _" [ALWAYS] forall @ (elem :: GHC.Types.*
                                                                                                         -> GHC.Types.*
                                                                                                         -> GHC.Types.*)
                                                                                              @ dom
                                                                                              ($dSourceInfo :: Language.Haskell.Tools.AST.Ann.SourceInfo
                                                                                                                 Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
  Language.Haskell.Tools.AST.Ann.$fHasRangeAnn_$cgetRange @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                                                          @ elem
                                                          @ dom
                                                          $dSourceInfo
  = RecordWildCardsChecker.$s$fHasRangeAnn_$s$fHasRangeAnn_$cgetRange
      @ elem
      @ dom
"SPEC/RecordWildCardsChecker $fMonadStateT @ Ghc _" [ALWAYS] forall @ s
                                                                    ($dMonad :: GHC.Base.Monad
                                                                                  GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fMonadStateT @ GhcMonad.Ghc
                                               @ s
                                               $dMonad
  = RecordWildCardsChecker.$s$fMonadStateT @ s
"SPEC/RecordWildCardsChecker $fMonadStateT_$c>> @ Ghc _" [ALWAYS] forall @ s
                                                                         ($dMonad :: GHC.Base.Monad
                                                                                       GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>> @ GhcMonad.Ghc
                                                    @ s
                                                    $dMonad
  = RecordWildCardsChecker.$s$fMonadStateT_$s$fMonadStateT_$c>> @ s
"SPEC/RecordWildCardsChecker $fMonadStateT_$c>>= @ Ghc _" [ALWAYS] forall @ s
                                                                          ($dMonad :: GHC.Base.Monad
                                                                                        GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>= @ GhcMonad.Ghc
                                                     @ s
                                                     $dMonad
  = RecordWildCardsChecker.$s$fMonadStateT_$s$fMonadStateT_$c>>= @ s
"SPEC/RecordWildCardsChecker $fMonadStateT_$cfail @ Ghc _" [ALWAYS] forall @ s
                                                                           ($dMonad :: GHC.Base.Monad
                                                                                         GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail @ GhcMonad.Ghc
                                                      @ s
                                                      $dMonad
  = RecordWildCardsChecker.$s$fMonadStateT_$s$fMonadStateT_$cfail @ s
"SPEC/RecordWildCardsChecker $fMonadStateT_$cp1Monad @ Ghc _" [ALWAYS] forall @ s
                                                                              ($dMonad :: GHC.Base.Monad
                                                                                            GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cp1Monad @ GhcMonad.Ghc
                                                         @ s
                                                         $dMonad
  = RecordWildCardsChecker.$s$fMonadStateT_$s$fMonadStateT_$cp1Monad
      @ s
"SPEC/RecordWildCardsChecker $fRefMonadswr @ (StateT
                                               (Map Extension [SrcSpan]) Ghc) @ Proxy" [ALWAYS] forall ($dMonad1 :: GHC.Base.Monad
                                                                                                                                                                           Data.Proxy.Proxy)
                                                                                                                                                            ($dApplicative1 :: GHC.Base.Applicative
                                                                                                                                                                                 Data.Proxy.Proxy)
                                                                                                                                                            ($dFunctor1 :: GHC.Base.Functor
                                                                                                                                                                             Data.Proxy.Proxy)
                                                                                                                                                            ($dMonad :: GHC.Base.Monad
                                                                                                                                                                          (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                             (Data.Map.Base.Map
                                                                                                                                                                                GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                [SrcLoc.SrcSpan])
                                                                                                                                                                             GhcMonad.Ghc))
                                                                                                                                                            ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                   (Data.Map.Base.Map
                                                                                                                                                                                      GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                      [SrcLoc.SrcSpan])
                                                                                                                                                                                   GhcMonad.Ghc))
                                                                                                                                                            ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                            (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                               (Data.Map.Base.Map
                                                                                                                                                                                  GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                  [SrcLoc.SrcSpan])
                                                                                                                                                                               GhcMonad.Ghc))
  Control.Reference.Representation.$fRefMonadswr @ (Control.Monad.Trans.State.Lazy.StateT
                                                      (Data.Map.Base.Map
                                                         GHC.LanguageExtensions.Type.Extension
                                                         [SrcLoc.SrcSpan])
                                                      GhcMonad.Ghc)
                                                 @ Data.Proxy.Proxy
                                                 $dFunctor
                                                 $dApplicative
                                                 $dMonad
                                                 $dFunctor1
                                                 $dApplicative1
                                                 $dMonad1
  = RecordWildCardsChecker.$s$fRefMonadswr
"SPEC/RecordWildCardsChecker $fRefMonadswr_$cp4RefMonads @ (StateT
                                                             (Map Extension [SrcSpan]) Ghc) @ Proxy" [ALWAYS] forall ($dMonad1 :: GHC.Base.Monad
                                                                                                                                                                                                       Data.Proxy.Proxy)
                                                                                                                                                                                        ($dApplicative1 :: GHC.Base.Applicative
                                                                                                                                                                                                             Data.Proxy.Proxy)
                                                                                                                                                                                        ($dFunctor1 :: GHC.Base.Functor
                                                                                                                                                                                                         Data.Proxy.Proxy)
                                                                                                                                                                                        ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                      (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                         (Data.Map.Base.Map
                                                                                                                                                                                                            GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                            [SrcLoc.SrcSpan])
                                                                                                                                                                                                         GhcMonad.Ghc))
                                                                                                                                                                                        ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                            (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                               (Data.Map.Base.Map
                                                                                                                                                                                                                  GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                                  [SrcLoc.SrcSpan])
                                                                                                                                                                                                               GhcMonad.Ghc))
                                                                                                                                                                                        ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                        (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                           (Data.Map.Base.Map
                                                                                                                                                                                                              GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                              [SrcLoc.SrcSpan])
                                                                                                                                                                                                           GhcMonad.Ghc))
  Control.Reference.Representation.$fRefMonadswr_$cp4RefMonads @ (Control.Monad.Trans.State.Lazy.StateT
                                                                    (Data.Map.Base.Map
                                                                       GHC.LanguageExtensions.Type.Extension
                                                                       [SrcLoc.SrcSpan])
                                                                    GhcMonad.Ghc)
                                                               @ Data.Proxy.Proxy
                                                               $dFunctor
                                                               $dApplicative
                                                               $dMonad
                                                               $dFunctor1
                                                               $dApplicative1
                                                               $dMonad1
  = RecordWildCardsChecker.$s$fRefMonadswr_$s$fRefMonadswr_$cp4RefMonads
"SPEC/RecordWildCardsChecker $fRefMonadswr_$cp5RefMonads @ (StateT
                                                             (Map Extension [SrcSpan]) Ghc) @ Proxy" [ALWAYS] forall ($dMonad1 :: GHC.Base.Monad
                                                                                                                                                                                                       Data.Proxy.Proxy)
                                                                                                                                                                                        ($dApplicative1 :: GHC.Base.Applicative
                                                                                                                                                                                                             Data.Proxy.Proxy)
                                                                                                                                                                                        ($dFunctor1 :: GHC.Base.Functor
                                                                                                                                                                                                         Data.Proxy.Proxy)
                                                                                                                                                                                        ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                      (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                         (Data.Map.Base.Map
                                                                                                                                                                                                            GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                            [SrcLoc.SrcSpan])
                                                                                                                                                                                                         GhcMonad.Ghc))
                                                                                                                                                                                        ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                            (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                               (Data.Map.Base.Map
                                                                                                                                                                                                                  GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                                  [SrcLoc.SrcSpan])
                                                                                                                                                                                                               GhcMonad.Ghc))
                                                                                                                                                                                        ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                        (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                           (Data.Map.Base.Map
                                                                                                                                                                                                              GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                              [SrcLoc.SrcSpan])
                                                                                                                                                                                                           GhcMonad.Ghc))
  Control.Reference.Representation.$fRefMonadswr_$cp5RefMonads @ (Control.Monad.Trans.State.Lazy.StateT
                                                                    (Data.Map.Base.Map
                                                                       GHC.LanguageExtensions.Type.Extension
                                                                       [SrcLoc.SrcSpan])
                                                                    GhcMonad.Ghc)
                                                               @ Data.Proxy.Proxy
                                                               $dFunctor
                                                               $dApplicative
                                                               $dMonad
                                                               $dFunctor1
                                                               $dApplicative1
                                                               $dMonad1
  = RecordWildCardsChecker.$s$fRefMonadswr_$s$fRefMonadswr_$cp5RefMonads
"SPEC/RecordWildCardsChecker $fRefMonadswr_$cp6RefMonads @ (StateT
                                                             (Map Extension [SrcSpan]) Ghc) @ Proxy" [ALWAYS] forall ($dMonad1 :: GHC.Base.Monad
                                                                                                                                                                                                       Data.Proxy.Proxy)
                                                                                                                                                                                        ($dApplicative1 :: GHC.Base.Applicative
                                                                                                                                                                                                             Data.Proxy.Proxy)
                                                                                                                                                                                        ($dFunctor1 :: GHC.Base.Functor
                                                                                                                                                                                                         Data.Proxy.Proxy)
                                                                                                                                                                                        ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                                      (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                         (Data.Map.Base.Map
                                                                                                                                                                                                            GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                            [SrcLoc.SrcSpan])
                                                                                                                                                                                                         GhcMonad.Ghc))
                                                                                                                                                                                        ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                            (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                               (Data.Map.Base.Map
                                                                                                                                                                                                                  GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                                  [SrcLoc.SrcSpan])
                                                                                                                                                                                                               GhcMonad.Ghc))
                                                                                                                                                                                        ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                        (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                           (Data.Map.Base.Map
                                                                                                                                                                                                              GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                              [SrcLoc.SrcSpan])
                                                                                                                                                                                                           GhcMonad.Ghc))
  Control.Reference.Representation.$fRefMonadswr_$cp6RefMonads @ (Control.Monad.Trans.State.Lazy.StateT
                                                                    (Data.Map.Base.Map
                                                                       GHC.LanguageExtensions.Type.Extension
                                                                       [SrcLoc.SrcSpan])
                                                                    GhcMonad.Ghc)
                                                               @ Data.Proxy.Proxy
                                                               $dFunctor
                                                               $dApplicative
                                                               $dMonad
                                                               $dFunctor1
                                                               $dApplicative1
                                                               $dMonad1
  = RecordWildCardsChecker.$s$fRefMonadswr_$s$fRefMonadswr_$cp6RefMonads
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

