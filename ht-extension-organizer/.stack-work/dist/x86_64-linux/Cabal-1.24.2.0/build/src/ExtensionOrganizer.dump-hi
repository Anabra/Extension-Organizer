
==================== FINAL INTERFACE ====================
2017-09-04 19:25:27.378504 UTC

interface ht-extension-organizer-0.1.0.0-1NgBbe619AH4JExLErEUCI:ExtensionOrganizer 8002
  interface hash: 55e8f1559da5f108c33ba714d3c37e0b
  ABI hash: c3ec034cfdf8d27e82e026d5f40fc218
  export-list hash: 6230781953da5a871b409009da4933a8
  orphan hash: baf891cfe1c6e3d67233249d3f717881
  flag hash: 3765faaf2f7c34423ae2f3781e67b8fa
  sig of: Nothing
  used TH splices: True
  where
exports:
  ExtensionOrganizer.collectExtensions
  ExtensionOrganizer.organizeExtensions
  ExtensionOrganizer.tryOut
module dependencies: DerivingsChecker ExtMonad
                     FlexibleInstancesChecker RecordWildCardsChecker
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 directory-1.3.0.0@directory-1.3.0.0
                      either-4.4.1.1@either-4.4.1.1-6PiwKYkn4v6B4KO2R2Fu1b
                      filepath-1.4.1.1@filepath-1.4.1.1 ghc-8.0.2
                      ghc-boot-8.0.2@ghc-boot-8.0.2 ghc-boot-th-8.0.2@ghc-boot-th-8.0.2
                      ghc-paths-0.1.0.9@ghc-paths-0.1.0.9-AhaDlGOsRAepox069XzG
                      ghc-prim-0.5.0.0 ghci-8.0.2@ghci-8.0.2
                      hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol
                      haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6
                      haskell-tools-backend-ghc-0.8.1.0@haskell-tools-backend-ghc-0.8.1.0-DqHnbK8OPi6CBD5cIPITWq
                      haskell-tools-prettyprint-0.8.1.0@haskell-tools-prettyprint-0.8.1.0-F9iWkGq5ppnLH6whHm0DlC
                      haskell-tools-refactor-0.8.1.0@haskell-tools-refactor-0.8.1.0-AF8Q4cA8mAnLNwu5t0Icw8
                      haskell-tools-rewrite-0.8.1.0@haskell-tools-rewrite-0.8.1.0-85A6q9dMQgvKEKG9I8fxVU
                      hoopl-3.10.2.1@hoopl-3.10.2.1 hpc-0.6.0.3@hpc-0.6.0.3
                      instance-control-0.1.1.1@instance-control-0.1.1.1-1defRS82vAAEmZKRhe67aa
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      pretty-1.1.3.3@pretty-1.1.3.3 process-1.4.3.0@process-1.4.3.0
                      references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo
                      safe-0.3.15@safe-0.3.15-2Yd45VWFfdcKqKyispOifY
                      split-0.2.3.2@split-0.2.3.2-CJl40zTyCIV16Pr60nb7CT
                      syb-0.7@syb-0.7-4OKdCpwGutyB1rNRmoa0ya template-haskell-2.11.1.0
                      text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00
                      time-1.6.0.1@time-1.6.0.1 transformers-0.5.2.0@transformers-0.5.2.0
                      uniplate-1.6.12@uniplate-1.6.12-4PyZX21trQJ5lfk0CDvC7U
                      unix-2.7.2.1@unix-2.7.2.1
                      unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         ghc-8.0.2:BlockId ghc-8.0.2:DsMonad ghc-8.0.2:LoadIface
         ghc-8.0.2:PPC.Ppr ghc-8.0.2:PprCmm ghc-8.0.2:PprCmmDecl
         ghc-8.0.2:PprCmmExpr ghc-8.0.2:PprCore ghc-8.0.2:SPARC.Ppr
         ghc-8.0.2:TcEnv ghc-8.0.2:TcRnMonad ghc-8.0.2:X86.Ppr
         ghc-boot-8.0.2@ghc-boot-8.0.2:GHC.LanguageExtensions
         ghci-8.0.2@ghci-8.0.2:GHCi.Message
         ghci-8.0.2@ghci-8.0.2:GHCi.TH.Binary
         hashable-1.2.6.1@hashable-1.2.6.1-2ZLNuHq395GGIHwEHuqZol:Data.Hashable.Generic
         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Instances.Data
         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Instances.Eq
         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Instances.Generic
         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Instances.SemanticTraversal
         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Instances.Show
         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Instances.SourceInfoTraversal
         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.SemaInfoTypes
         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Utils.GHCInstances
         haskell-tools-backend-ghc-0.8.1.0@haskell-tools-backend-ghc-0.8.1.0-DqHnbK8OPi6CBD5cIPITWq:Language.Haskell.Tools.AST.FromGHC.Utils
         haskell-tools-prettyprint-0.8.1.0@haskell-tools-prettyprint-0.8.1.0-F9iWkGq5ppnLH6whHm0DlC:Language.Haskell.Tools.Transform.RangeTemplate
         haskell-tools-prettyprint-0.8.1.0@haskell-tools-prettyprint-0.8.1.0-F9iWkGq5ppnLH6whHm0DlC:Language.Haskell.Tools.Transform.SourceTemplate
         haskell-tools-prettyprint-0.8.1.0@haskell-tools-prettyprint-0.8.1.0-F9iWkGq5ppnLH6whHm0DlC:Language.Haskell.Tools.Transform.SourceTemplateHelpers
         haskell-tools-refactor-0.8.1.0@haskell-tools-refactor-0.8.1.0-AF8Q4cA8mAnLNwu5t0Icw8:Language.Haskell.Tools.Refactor.RefactorBase
         ht-extension-organizer-0.1.0.0-1NgBbe619AH4JExLErEUCI:ExtMonad
         references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo:Control.Reference.Predefined.Containers.Tree
         references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo:Control.Reference.TH.Records
         syb-0.7@syb-0.7-4OKdCpwGutyB1rNRmoa0ya:Data.Generics.Instances
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Show
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
         uniplate-1.6.12@uniplate-1.6.12-4PyZX21trQJ5lfk0CDvC7U:Data.Generics.Uniplate.Data
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Compose base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.Functor.Product base-4.9.1.0:Data.Functor.Sum
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         ghc-8.0.2:PlaceHolder ghc-8.0.2:TrieMap
                         ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type
                         ghci-8.0.2@ghci-8.0.2:GHCi.FFI ghci-8.0.2@ghci-8.0.2:GHCi.Message
                         ghci-8.0.2@ghci-8.0.2:GHCi.ResolvedBCO
                         ghci-8.0.2@ghci-8.0.2:SizedSeq
                         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Ann
                         haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Instances.Generic
                         haskell-tools-prettyprint-0.8.1.0@haskell-tools-prettyprint-0.8.1.0-F9iWkGq5ppnLH6whHm0DlC:Language.Haskell.Tools.Transform.RangeTemplate
                         haskell-tools-prettyprint-0.8.1.0@haskell-tools-prettyprint-0.8.1.0-F9iWkGq5ppnLH6whHm0DlC:Language.Haskell.Tools.Transform.SourceTemplate
                         hoopl-3.10.2.1@hoopl-3.10.2.1:Compiler.Hoopl.Block
                         hoopl-3.10.2.1@hoopl-3.10.2.1:Compiler.Hoopl.Dataflow
                         hoopl-3.10.2.1@hoopl-3.10.2.1:Compiler.Hoopl.Fuel
                         hoopl-3.10.2.1@hoopl-3.10.2.1:Compiler.Hoopl.Label
                         hoopl-3.10.2.1@hoopl-3.10.2.1:Compiler.Hoopl.Unique
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
                         references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo:Control.Reference.Predefined.Containers
                         references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo:Control.Reference.Predefined.Containers.Tree
                         references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo:Control.Reference.Types
                         template-haskell-2.11.1.0:Language.Haskell.TH.Syntax
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text
                         text-1.2.2.2@text-1.2.2.2-9UQZjEJZQFSGMffj1Z5g00:Data.Text.Lazy
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashMap.Base
                         unordered-containers-0.2.8.0@unordered-containers-0.2.8.0-Bp9XgxjuHxcI4tFehVMDGC:Data.HashSet
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.Ix a87f5170bf213161cce2e025974f49b5
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.Traversable 556020d7cf3c4a34a774600512918a37
import  -/  base-4.9.1.0:Debug.Trace a9edf3aec504f4423d8ba829ab373a25
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base d432f6875983131473086af8cb290590
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Strict 9d0c0962e53270a0a3fb5cb63723a381
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Set 3ed2324fd1e757464a8ac2b636a64e5a
import  -/  ghc-8.0.2:GHC 2331686350095b94008a49ce7901eaa2
import  -/  ghc-8.0.2:GhcMonad fe90acc3f77ca6bdb0686328a3d31d0f
import  -/  ghc-8.0.2:SrcLoc ae8e460a2b77026f9c6a4d6cdcc5d57e
import  -/  ghc-boot-th-8.0.2@ghc-boot-th-8.0.2:GHC.LanguageExtensions.Type 92441ea50916fa3940e20fae60f255d7
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.Ann 07e8f66a2b6d7f18951fb774264c8644
import  -/  haskell-tools-ast-0.8.1.0@haskell-tools-ast-0.8.1.0-I9ZMaCkuuwT3FoQkwMjyW6:Language.Haskell.Tools.AST.References 46cb31a69f53297ab865876852473aa3
import  -/  haskell-tools-prettyprint-0.8.1.0@haskell-tools-prettyprint-0.8.1.0-F9iWkGq5ppnLH6whHm0DlC:Language.Haskell.Tools.PrettyPrint da7dea6ac299ef1620d7160216fb97b0
import  -/  haskell-tools-refactor-0.8.1.0@haskell-tools-refactor-0.8.1.0-AF8Q4cA8mAnLNwu5t0Icw8:Language.Haskell.Tools.Refactor 84acc8d60e278de91351468f26f90e1c
import  -/  haskell-tools-refactor-0.8.1.0@haskell-tools-refactor-0.8.1.0-AF8Q4cA8mAnLNwu5t0Icw8:Language.Haskell.Tools.Refactor.Prepare 06c995907993af4dca8399eaa224a412
import  -/  haskell-tools-refactor-0.8.1.0@haskell-tools-refactor-0.8.1.0-AF8Q4cA8mAnLNwu5t0Icw8:Language.Haskell.Tools.Refactor.RefactorBase d8cc79a36102a900280f4d51e9bf8f8a
import  -/  DerivingsChecker 181dff829ccf9783a809f45a09f136cb
  exports: 7107769a0700dc60bd2de915d80cd0cd
  chkDerivings 4b61a1dd8af45174549972bf9da76d39
import  -/  ExtMonad 6efef839e8084e4944c989299f7e8b99
  exports: 78fe3d4ca4f10930e37e7961f002463e
  ExtDomain 9c2711a12fb4585de58cde40d63b8c17
import  -/  FlexibleInstancesChecker 43c608ae83cfe4e8d3fe93b659d7aa33
  exports: efcaf24a44a888cb7dc5984a59c70ac0
  chkFlexibleInstances 1203552a74e835e6dc8a519272e2bb77
import  -/  RecordWildCardsChecker 12f3b9bedb54acbffe9e9f963498b748
  exports: 9eefb0279d08d0f59521eb14428b9b37
  chkRecordWildCards 8d1716c00d854869a620193269d56467
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State 749dca8ca0e6625b32091d445bd92b01
import  -/  references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo:Control.Reference d89ee82346f6e25c55a8a19dbf84658e
import  -/  references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo:Control.Reference.Combinators ab836299cfb9898d02f637bc65b3765a
import  -/  references-0.3.2.2@references-0.3.2.2-y362bKYomIKNQKMTfOWVo:Control.Reference.Operators 55e717f4df077a71cb70a96f85f6a393
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 371607e50dde46b5f4103b3ab334a497
Module target ht-extension-organizer-0.1.0.0-1NgBbe619AH4JExLErEUCI:ExtensionOrganizer annotated by 1269 of type [Char]
Module target ht-extension-organizer-0.1.0.0-1NgBbe619AH4JExLErEUCI:ExtensionOrganizer annotated by 1059 of type [Char]
6422e66d8a71f70253544a68a6e3423c
  $s$fApplicativeStateT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc)
                  (ExtensionOrganizer.$s$fApplicativeStateT_$s$fApplicativeStateT_$cp1Applicative
                     @ s)
                  (ExtensionOrganizer.$s$fApplicativeStateT_$s$fApplicativeStateT_$cpure
                     @ s)
                  (ExtensionOrganizer.$s$fApplicativeStateT_$s$fApplicativeStateT_$c<*>
                     @ s)
                  (Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c*>
                     @ GhcMonad.Ghc
                     @ s
                     ExtensionOrganizer.$s$fApplicativeStateT_$dFunctor
                     GhcMonad.$fMonadGhc)
                  (Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c<*
                     @ GhcMonad.Ghc
                     @ s
                     ExtensionOrganizer.$s$fApplicativeStateT_$dFunctor
                     GhcMonad.$fMonadGhc) -}
c07d26816cf5c05afba53989813dcf14
  $s$fApplicativeStateT_$dFunctor :: GHC.Base.Functor GhcMonad.Ghc
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) GhcMonad.$fFunctorGhc -}
3152039a86bf0c51893ab1e1015be890
  $s$fApplicativeStateT_$s$fApplicativeStateT_$c<*> ::
    Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a
    -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,C(C1(C1(U(U,U(1*U,1*U)))))><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (ds :: Control.Monad.Trans.State.Lazy.StateT
                            s GhcMonad.Ghc (a -> b))
                   (ds1 :: Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> GhcMonad.Ghc (b, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b)
                   (\ (tpl :: s -> GhcMonad.Ghc (b, s)) -> tpl)
                     `cast`
                   (<s -> GhcMonad.Ghc (b, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <GhcMonad.Ghc>_R <b>_N))
                   (\ (s1 :: s) ->
                    GhcMonad.$fMonadGhc_$c>>=
                      @ (a -> b, s)
                      @ (b, s)
                      (ds
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <s>_N <GhcMonad.Ghc>_R <a -> b>_N)
                         s1)
                      (\ (ds2 :: (a -> b, s)) ->
                       GhcMonad.$fMonadGhc_$c>>=
                         @ (a, s)
                         @ (b, s)
                         (ds1
                            `cast`
                          (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <s>_N <GhcMonad.Ghc>_R <a>_N)
                            (case ds2 of wild { (,) f s' -> s' }))
                         (\ (ds3 :: (a, s)) ->
                          GhcMonad.$fApplicativeGhc_$cpure
                            @ (b, s)
                            (case ds2 of wild { (,) f s' ->
                             f (case ds3 of wild1 { (,) x s'' -> x }) },
                             case ds3 of wild { (,) x s'' -> s'' }))))) -}
ee357dd60d9a8876d21385f68ee9ede6
  $s$fApplicativeStateT_$s$fApplicativeStateT_$cp1Applicative ::
    GHC.Base.Functor
      (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                ExtensionOrganizer.$s$fApplicativeStateT_$s$fFunctorStateT -}
dcc9b05b0f7f42c26f5ce8256132847e
  $s$fApplicativeStateT_$s$fApplicativeStateT_$cpure ::
    a -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,A><S,U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s @ a (a3 :: a) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> GhcMonad.Ghc (a, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a)
                   (\ (tpl :: s -> GhcMonad.Ghc (a, s)) -> tpl)
                     `cast`
                   (<s -> GhcMonad.Ghc (a, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <GhcMonad.Ghc>_R <a>_N))
                   (\ (s1 :: s)
                      (eta :: GhcMonad.Session)
                      (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                    ((GhcMonad.$fApplicativeGhc_$cpure @ (a, s) (a3, s1))
                       `cast`
                     (GhcMonad.N:Ghc[0] <(a, s)>_R)
                       eta)
                      `cast`
                    (GHC.Types.N:IO[0] <(a, s)>_R)
                      eta1)
                     `cast`
                   (<s>_R
                    ->_R Trans
                             (<GhcMonad.Session>_R ->_R Sym (GHC.Types.N:IO[0] <(a, s)>_R))
                             (Sym (GhcMonad.N:Ghc[0] <(a, s)>_R)))) -}
1bc3f6409af449cc081ea68dd46589a0
  $s$fApplicativeStateT_$s$fFunctorStateT ::
    GHC.Base.Functor
      (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc)
                  (ExtensionOrganizer.$s$fApplicativeStateT_$s$fFunctorStateT_$cfmap
                     @ s)
                  (Control.Monad.Trans.State.Lazy.$fFunctorStateT_$c<$
                     @ GhcMonad.Ghc
                     @ s
                     GhcMonad.$fFunctorGhc) -}
96751ee352032de5ed7e287501335e41
  $s$fApplicativeStateT_$s$fFunctorStateT_$cfmap ::
    (a -> b)
    -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a
    -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(U)><L,1*C1(U)><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (f :: a -> b)
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> GhcMonad.Ghc (b, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b)
                   (\ (tpl :: s -> GhcMonad.Ghc (b, s)) -> tpl)
                     `cast`
                   (<s -> GhcMonad.Ghc (b, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <GhcMonad.Ghc>_R <b>_N))
                   (\ (s1 :: s) ->
                    GHC.Base.$
                      @ 'GHC.Types.PtrRepLifted
                      @ (GhcMonad.Ghc (a, s))
                      @ (GhcMonad.Ghc (b, s))
                      (GhcMonad.$fFunctorGhc_$cfmap
                         @ (a, s)
                         @ (b, s)
                         (\ (ds :: (a, s)) ->
                          (f (case ds of wild { (,) a3 s' -> a3 }),
                           case ds of wild { (,) a3 s' -> s' })))
                      (Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ GhcMonad.Ghc
                         @ a
                         m1
                         s1))) -}
69b3cfd9f20ac9a05c766fa72dadf3d2
  $s$fDataImportInfo ::
    Data.Data.Data
      (Language.Haskell.Tools.AST.SemaInfoTypes.ImportInfo Var.Var)
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Haskell.Tools.AST.SemaInfoTypes.ImportInfo Var.Var)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImportInfo_$cp1Data
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImportInfo_$cgfoldl
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImportInfo_$cgunfold
                     @ Var.Var
                     Var.$fDataVar)
                  ExtensionOrganizer.$s$fDataImportInfo_$s$fDataImportInfo_$ctoConstr
                  ExtensionOrganizer.$s$fDataImportInfo_$s$fDataImportInfo_$cdataTypeOf
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImportInfo_$cdataCast1
                     @ Var.Var
                     Var.$fDataVar)
                  ExtensionOrganizer.$s$fDataImportInfo_$s$fDataImportInfo_$cdataCast2
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImportInfo_$cgmapT
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImportInfo_$cgmapQl
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImportInfo_$cgmapQr
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImportInfo_$cgmapQ
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImportInfo_$cgmapQi
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImportInfo_$cgmapM
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImportInfo_$cgmapMp
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImportInfo_$cgmapMo
                     @ Var.Var
                     Var.$fDataVar) -}
bffb859162c86f269b46f8158c4a7d11
  $s$fDataImportInfo_$s$fDataImportInfo_$cdataCast2 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe
         (c (Language.Haskell.Tools.AST.SemaInfoTypes.ImportInfo Var.Var))
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds1 :: forall d e.
                           (Data.Data.Data d, Data.Data.Data e) =>
                           c (t d e)) ->
                 GHC.Base.Nothing
                   @ (c (Language.Haskell.Tools.AST.SemaInfoTypes.ImportInfo
                           Var.Var))) -}
a9c18a95bc4295730e1b451acf9ed575
  $s$fDataImportInfo_$s$fDataImportInfo_$cdataTypeOf ::
    Language.Haskell.Tools.AST.SemaInfoTypes.ImportInfo Var.Var
    -> Data.Data.DataType
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds1 :: Language.Haskell.Tools.AST.SemaInfoTypes.ImportInfo
                             Var.Var) ->
                 Language.Haskell.Tools.AST.SemaInfoTypes.$tCGCyyeAJlLA79SU0hhqeif) -}
2642dd9a959495743b4d757e91662f4b
  $s$fDataImportInfo_$s$fDataImportInfo_$ctoConstr ::
    Language.Haskell.Tools.AST.SemaInfoTypes.ImportInfo Var.Var
    -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*H>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: Language.Haskell.Tools.AST.SemaInfoTypes.ImportInfo
                             Var.Var) ->
                 case ds1 of wild { Language.Haskell.Tools.AST.SemaInfoTypes.ImportInfo ds2 ds3 ds4 ds5 ds6 ->
                 Language.Haskell.Tools.AST.SemaInfoTypes.$cCGCyyeAJlLA79SU0hhqeif }) -}
dc9a37eaa445436a23008ad60d530b67
  $s$fDataModuleInfo ::
    Data.Data.Data
      (Language.Haskell.Tools.AST.SemaInfoTypes.ModuleInfo Var.Var)
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Haskell.Tools.AST.SemaInfoTypes.ModuleInfo Var.Var)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataModuleInfo_$cp1Data
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataModuleInfo_$cgfoldl
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataModuleInfo_$cgunfold
                     @ Var.Var
                     Var.$fDataVar)
                  ExtensionOrganizer.$s$fDataModuleInfo_$s$fDataModuleInfo_$ctoConstr
                  ExtensionOrganizer.$s$fDataModuleInfo_$s$fDataModuleInfo_$cdataTypeOf
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataModuleInfo_$cdataCast1
                     @ Var.Var
                     Var.$fDataVar)
                  ExtensionOrganizer.$s$fDataModuleInfo_$s$fDataModuleInfo_$cdataCast2
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataModuleInfo_$cgmapT
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataModuleInfo_$cgmapQl
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataModuleInfo_$cgmapQr
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataModuleInfo_$cgmapQ
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataModuleInfo_$cgmapQi
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataModuleInfo_$cgmapM
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataModuleInfo_$cgmapMp
                     @ Var.Var
                     Var.$fDataVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fDataModuleInfo_$cgmapMo
                     @ Var.Var
                     Var.$fDataVar) -}
fc0b050ead130fb872f447bbb0083359
  $s$fDataModuleInfo_$s$fDataModuleInfo_$cdataCast2 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d e. (Data.Data.Data d, Data.Data.Data e) => c (t d e))
    -> GHC.Base.Maybe
         (c (Language.Haskell.Tools.AST.SemaInfoTypes.ModuleInfo Var.Var))
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (t :: * -> * -> *)
                   @ (c :: * -> *)
                   ($dTypeable :: Data.Typeable.Internal.Typeable t)
                   (ds1 :: forall d e.
                           (Data.Data.Data d, Data.Data.Data e) =>
                           c (t d e)) ->
                 GHC.Base.Nothing
                   @ (c (Language.Haskell.Tools.AST.SemaInfoTypes.ModuleInfo
                           Var.Var))) -}
29e7d1e144629ad64964d507dd8fb721
  $s$fDataModuleInfo_$s$fDataModuleInfo_$cdataTypeOf ::
    Language.Haskell.Tools.AST.SemaInfoTypes.ModuleInfo Var.Var
    -> Data.Data.DataType
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds1 :: Language.Haskell.Tools.AST.SemaInfoTypes.ModuleInfo
                             Var.Var) ->
                 Language.Haskell.Tools.AST.SemaInfoTypes.$t8kQvtqUmj9O26DNBHuLtDJ) -}
f4e6689987d8e4615d3c1ccafbc97b8a
  $s$fDataModuleInfo_$s$fDataModuleInfo_$ctoConstr ::
    Language.Haskell.Tools.AST.SemaInfoTypes.ModuleInfo Var.Var
    -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*H>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: Language.Haskell.Tools.AST.SemaInfoTypes.ModuleInfo
                             Var.Var) ->
                 case ds1 of wild { Language.Haskell.Tools.AST.SemaInfoTypes.ModuleInfo ds2 ds3 ds4 ds5 ds6 ds7 ->
                 Language.Haskell.Tools.AST.SemaInfoTypes.$c8kQvtqUmj9O26DNBHuLtDJ }) -}
e29366255201aa8bf72931bb3891417d
  $s$fDataUModule ::
    Data.Data.Data
      (Language.Haskell.Tools.AST.Representation.Modules.UModule
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Haskell.Tools.AST.Representation.Modules.UModule
                       Language.Haskell.Tools.AST.Ann.IdDom
                       Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                  (Language.Haskell.Tools.AST.Instances.Data.$fDataUModule_$cp1Data
                     @ Language.Haskell.Tools.AST.Ann.IdDom
                     @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                     ExtensionOrganizer.$s$fDataUModule4
                     Language.Haskell.Tools.Transform.SourceTemplate.$fSourceInfoSrcTemplateStage)
                  (Language.Haskell.Tools.AST.Instances.Data.$fDataUModule_$cgfoldl
                     @ Language.Haskell.Tools.AST.Ann.IdDom
                     @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                     ExtensionOrganizer.$s$fDataUModule4
                     Language.Haskell.Tools.Transform.SourceTemplate.$fSourceInfoSrcTemplateStage)
                  (Language.Haskell.Tools.AST.Instances.Data.$fDataUModule_$cgunfold
                     @ Language.Haskell.Tools.AST.Ann.IdDom
                     @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                     ExtensionOrganizer.$s$fDataUModule4
                     Language.Haskell.Tools.Transform.SourceTemplate.$fSourceInfoSrcTemplateStage)
                  ExtensionOrganizer.$s$fDataUModule3
                  ExtensionOrganizer.$s$fDataUModule2
                  ExtensionOrganizer.$s$fDataUModule1
                  (Language.Haskell.Tools.AST.Instances.Data.$fDataUModule_$cdataCast2
                     @ Language.Haskell.Tools.AST.Ann.IdDom
                     @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                     ExtensionOrganizer.$s$fDataUModule4
                     Language.Haskell.Tools.Transform.SourceTemplate.$fSourceInfoSrcTemplateStage)
                  (Language.Haskell.Tools.AST.Instances.Data.$fDataUModule_$cgmapT
                     @ Language.Haskell.Tools.AST.Ann.IdDom
                     @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                     ExtensionOrganizer.$s$fDataUModule4
                     Language.Haskell.Tools.Transform.SourceTemplate.$fSourceInfoSrcTemplateStage)
                  (Language.Haskell.Tools.AST.Instances.Data.$fDataUModule_$cgmapQl
                     @ Language.Haskell.Tools.AST.Ann.IdDom
                     @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                     ExtensionOrganizer.$s$fDataUModule4
                     Language.Haskell.Tools.Transform.SourceTemplate.$fSourceInfoSrcTemplateStage)
                  (Language.Haskell.Tools.AST.Instances.Data.$fDataUModule_$cgmapQr
                     @ Language.Haskell.Tools.AST.Ann.IdDom
                     @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                     ExtensionOrganizer.$s$fDataUModule4
                     Language.Haskell.Tools.Transform.SourceTemplate.$fSourceInfoSrcTemplateStage)
                  (Language.Haskell.Tools.AST.Instances.Data.$fDataUModule_$cgmapQ
                     @ Language.Haskell.Tools.AST.Ann.IdDom
                     @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                     ExtensionOrganizer.$s$fDataUModule4
                     Language.Haskell.Tools.Transform.SourceTemplate.$fSourceInfoSrcTemplateStage)
                  (Language.Haskell.Tools.AST.Instances.Data.$fDataUModule_$cgmapQi
                     @ Language.Haskell.Tools.AST.Ann.IdDom
                     @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                     ExtensionOrganizer.$s$fDataUModule4
                     Language.Haskell.Tools.Transform.SourceTemplate.$fSourceInfoSrcTemplateStage)
                  (Language.Haskell.Tools.AST.Instances.Data.$fDataUModule_$cgmapM
                     @ Language.Haskell.Tools.AST.Ann.IdDom
                     @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                     ExtensionOrganizer.$s$fDataUModule4
                     Language.Haskell.Tools.Transform.SourceTemplate.$fSourceInfoSrcTemplateStage)
                  (Language.Haskell.Tools.AST.Instances.Data.$fDataUModule_$cgmapMp
                     @ Language.Haskell.Tools.AST.Ann.IdDom
                     @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                     ExtensionOrganizer.$s$fDataUModule4
                     Language.Haskell.Tools.Transform.SourceTemplate.$fSourceInfoSrcTemplateStage)
                  (Language.Haskell.Tools.AST.Instances.Data.$fDataUModule_$cgmapMo
                     @ Language.Haskell.Tools.AST.Ann.IdDom
                     @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                     ExtensionOrganizer.$s$fDataUModule4
                     Language.Haskell.Tools.Transform.SourceTemplate.$fSourceInfoSrcTemplateStage) -}
9ae922bf63255966b3c4640d1a0985fe
  $s$fDataUModule1 ::
    Data.Typeable.Internal.Typeable t =>
    (forall d. Data.Data.Data d => c (t d))
    -> GHC.Base.Maybe
         (c (Language.Haskell.Tools.AST.Representation.Modules.UModule
               Language.Haskell.Tools.AST.Ann.IdDom
               Language.Haskell.Tools.AST.Ann.SrcTemplateStage))
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ (t :: * -> *)
                   @ (c :: * -> *)
                   (eta :: Data.Typeable.Internal.Typeable t)
                   (eta1 :: forall d. Data.Data.Data d => c (t d)) ->
                 GHC.Base.Nothing
                   @ (c (Language.Haskell.Tools.AST.Representation.Modules.UModule
                           Language.Haskell.Tools.AST.Ann.IdDom
                           Language.Haskell.Tools.AST.Ann.SrcTemplateStage))) -}
6bb4348c136a7a9d6012714c5ce96ce0
  $s$fDataUModule10 ::
    Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo
    GHC.Types.~~ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Eq#
                   @ *
                   @ *
                   @ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo
                   @ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo
                   @~ <Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo>_N) -}
19eda48831fb6f7f5ccb0c16e363d5f8
  $s$fDataUModule11 ::
    Data.Typeable.Internal.Typeable
      Language.Haskell.Tools.AST.Ann.IdDom
  {- Arity: 1, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                ExtensionOrganizer.$s$fDataUModule12
                  `cast`
                (Sym (Data.Typeable.Internal.N:Typeable[0]
                          <*>_N <Language.Haskell.Tools.AST.Ann.IdDom>_N)) -}
04ec1166808492663dcc0023024ee3ad
  $s$fDataUModule12 ::
    GHC.Prim.Proxy# Language.Haskell.Tools.AST.Ann.IdDom
    -> Data.Typeable.Internal.TypeRep
  {- Arity: 1, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (wild :: GHC.Prim.Proxy#
                              Language.Haskell.Tools.AST.Ann.IdDom) ->
                 ExtensionOrganizer.$s$fDataUModule13) -}
54a2b4ff33f41b0f1f5d8427026170b6
  $s$fDataUModule13 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           ExtensionOrganizer.$s$fDataUModule14
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Haskell.Tools.AST.Ann.$tcIdDom
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
e32aa358f0292c68fcb1250f690e2127
  $s$fDataUModule14 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   11145549849738423769##
                   13393259708013230772##) -}
be13c2ed76dfbdbd28a4f93e00efc590
  $s$fDataUModule2 ::
    Language.Haskell.Tools.AST.Representation.Modules.UModule
      Language.Haskell.Tools.AST.Ann.IdDom
      Language.Haskell.Tools.AST.Ann.SrcTemplateStage
    -> Data.Data.DataType
  {- Arity: 1, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (eta :: Language.Haskell.Tools.AST.Representation.Modules.UModule
                             Language.Haskell.Tools.AST.Ann.IdDom
                             Language.Haskell.Tools.AST.Ann.SrcTemplateStage) ->
                 Language.Haskell.Tools.AST.Instances.Data.$tHikzE5Jygd387qE1NMUDik) -}
3729ab97a998c0ecb7e06c926ff37608
  $s$fDataUModule3 ::
    Language.Haskell.Tools.AST.Representation.Modules.UModule
      Language.Haskell.Tools.AST.Ann.IdDom
      Language.Haskell.Tools.AST.Ann.SrcTemplateStage
    -> Data.Data.Constr
  {- Arity: 1, Strictness: <S,1*H>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: Language.Haskell.Tools.AST.Representation.Modules.UModule
                             Language.Haskell.Tools.AST.Ann.IdDom
                             Language.Haskell.Tools.AST.Ann.SrcTemplateStage) ->
                 case eta of wild { Language.Haskell.Tools.AST.Representation.Modules.UModule ds14 ds15 ds16 ds17 ->
                 Language.Haskell.Tools.AST.Instances.Data.$cHikzE5Jygd387qE1NMUDik }) -}
80720db08e88249c5b9d5a86fe2cff8d
  $s$fDataUModule4 ::
    Language.Haskell.Tools.AST.Ann.Domain
      Language.Haskell.Tools.AST.Ann.IdDom
  {- Unfolding: InlineRule (0, True, True)
                ExtensionOrganizer.$s$fDataUModule_$s$fDomaind -}
924de804537896380b659387ab42e8b2
  $s$fDataUModule5 ::
    GHC.Show.Show
      (Language.Haskell.Tools.AST.SemaInfoTypes.ModuleInfo Var.Id)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                ExtensionOrganizer.$s$fDataUModule_$s$fShowModuleInfo -}
ff4324ee5de0c738d5d4fa011594bcf9
  $s$fDataUModule6 ::
    GHC.Show.Show
      (Language.Haskell.Tools.AST.SemaInfoTypes.ImportInfo Var.Id)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                ExtensionOrganizer.$s$fDataUModule_$s$fShowImportInfo -}
57492606f66de1b78beff5a4dba2056c
  $s$fDataUModule7 ::
    Data.Data.Data
      (Language.Haskell.Tools.AST.SemaInfoTypes.ModuleInfo Var.Id)
  {- Unfolding: InlineRule (0, True, True)
                ExtensionOrganizer.$s$fDataModuleInfo -}
96f7783145341c93c536c10f6de8d413
  $s$fDataUModule8 ::
    Data.Data.Data
      (Language.Haskell.Tools.AST.SemaInfoTypes.ImportInfo Var.Id)
  {- Unfolding: InlineRule (0, True, True)
                ExtensionOrganizer.$s$fDataImportInfo -}
df0ab977ab7b7dc006af120f3552095d
  $s$fDataUModule9 ::
    Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo
    Data.Type.Equality.~ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                ExtensionOrganizer.$s$fDataUModule10
                  `cast`
                (Sym (Data.Type.Equality.N:~[0]
                          <*>_N) <Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo>_N <Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo>_N) -}
7235ab3e2f9d223a346f59294110855d
  $s$fDataUModule_$s$fDomaind ::
    Language.Haskell.Tools.AST.Ann.Domain
      Language.Haskell.Tools.AST.Ann.IdDom
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Language.Haskell.Tools.AST.Ann.IdDom
                  ExtensionOrganizer.$s$fDataUModule11
                  ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp2Domain
                  ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp3Domain
                  ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp4Domain
                  ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp5Domain
                  ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp6Domain
                  ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp7Domain
                  ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp8Domain
                  ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp9Domain
                  ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp10Domain
                  ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp11Domain
                  ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp12Domain
                  ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp13Domain -}
3f03d309c637d604eb8f3bb7d78135c8
  $s$fDataUModule_$s$fDomaind_$cp10Domain ::
    GHC.Show.Show
      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SameInfoExprCls)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Language.Haskell.Tools.AST.SemaInfoTypes.$fShowScopeInfo
                  `cast`
                (GHC.Show.Show
                   (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoExprCls[0])))_R -}
3167256479b0a4bb296b31373ea2e18d
  $s$fDataUModule_$s$fDomaind_$cp11Domain ::
    GHC.Show.Show
      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SameInfoImportCls)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                ExtensionOrganizer.$s$fDataUModule6
                  `cast`
                (GHC.Show.Show
                   (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoImportCls[0])))_R -}
0e3364fc868315b17203670fff6933c2
  $s$fDataUModule_$s$fDomaind_$cp12Domain ::
    GHC.Show.Show
      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SameInfoModuleCls)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                ExtensionOrganizer.$s$fDataUModule5
                  `cast`
                (GHC.Show.Show
                   (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoModuleCls[0])))_R -}
5993c6b67f7df735efb30e8bd65f330e
  $s$fDataUModule_$s$fDomaind_$cp13Domain ::
    GHC.Show.Show
      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Language.Haskell.Tools.AST.SemaInfoTypes.$fShowImplicitFieldInfo
                  `cast`
                (GHC.Show.Show
                   (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoWildcardCls[0])))_R -}
cb2845268689b82a60a0a90411d993ed
  $s$fDataUModule_$s$fDomaind_$cp2Domain ::
    Data.Data.Data Language.Haskell.Tools.AST.Ann.IdDom
  {- Unfolding: InlineRule (0, True, True)
                Language.Haskell.Tools.AST.Ann.$fDataIdDom -}
7a373fd07c26bdf417f7007920189a1a
  $s$fDataUModule_$s$fDomaind_$cp3Domain ::
    Language.Haskell.Tools.AST.Ann.SemanticInfo'
      Language.Haskell.Tools.AST.Ann.IdDom
      Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls
    Data.Type.Equality.~ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                ExtensionOrganizer.$s$fDataUModule9
                  `cast`
                ((Data.Type.Equality.~)
                   <*>_N
                   (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoDefaultCls[0]))
                   <Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo>_N)_R -}
d0853dadfa9c44bd6a054b635a2c1449
  $s$fDataUModule_$s$fDomaind_$cp4Domain ::
    Data.Data.Data
      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SameInfoNameCls)
  {- Unfolding: InlineRule (0, True, True)
                Language.Haskell.Tools.AST.SemaInfoTypes.$fDataCNameInfo
                  `cast`
                (Data.Data.Data
                   (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoNameCls[0])))_R -}
58015b7000dc063cf7764c438ba1ca6f
  $s$fDataUModule_$s$fDomaind_$cp5Domain ::
    Data.Data.Data
      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SameInfoExprCls)
  {- Unfolding: InlineRule (0, True, True)
                Language.Haskell.Tools.AST.SemaInfoTypes.$fDataScopeInfo
                  `cast`
                (Data.Data.Data
                   (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoExprCls[0])))_R -}
aa9dacd80aab141e1fc195d89ffaba09
  $s$fDataUModule_$s$fDomaind_$cp6Domain ::
    Data.Data.Data
      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SameInfoImportCls)
  {- Unfolding: InlineRule (0, True, True)
                ExtensionOrganizer.$s$fDataUModule8
                  `cast`
                (Data.Data.Data
                   (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoImportCls[0])))_R -}
481093c44e1bf292c0b87c061b1fcd2d
  $s$fDataUModule_$s$fDomaind_$cp7Domain ::
    Data.Data.Data
      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SameInfoModuleCls)
  {- Unfolding: InlineRule (0, True, True)
                ExtensionOrganizer.$s$fDataUModule7
                  `cast`
                (Data.Data.Data
                   (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoModuleCls[0])))_R -}
1eb9e9300179612237d27888c6a0c62f
  $s$fDataUModule_$s$fDomaind_$cp8Domain ::
    Data.Data.Data
      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls)
  {- Unfolding: InlineRule (0, True, True)
                Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImplicitFieldInfo
                  `cast`
                (Data.Data.Data
                   (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoWildcardCls[0])))_R -}
31a8c2372814025aba944cede0bafd39
  $s$fDataUModule_$s$fDomaind_$cp9Domain ::
    GHC.Show.Show
      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SameInfoNameCls)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Language.Haskell.Tools.AST.SemaInfoTypes.$fShowCNameInfo
                  `cast`
                (GHC.Show.Show
                   (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoNameCls[0])))_R -}
42edd8bab818beed629915085385d5d2
  $s$fDataUModule_$s$fShowImportInfo ::
    GHC.Show.Show
      (Language.Haskell.Tools.AST.SemaInfoTypes.ImportInfo Var.Var)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Haskell.Tools.AST.SemaInfoTypes.ImportInfo Var.Var)
                  ExtensionOrganizer.$s$fDataUModule_$s$fShowImportInfo_$cshowsPrec
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fShowImportInfo_$cshow
                     @ Var.Var
                     Var.$fOutputableVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fShowImportInfo_$cshowList
                     @ Var.Var
                     Var.$fOutputableVar) -}
5349c8d4359cd77891e00bc6d32794e9
  $s$fDataUModule_$s$fShowImportInfo_$cshowsPrec ::
    GHC.Types.Int
    -> Language.Haskell.Tools.AST.SemaInfoTypes.ImportInfo Var.Var
    -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,A><S,1*U(1*U(U(U,U,U,U,U,U,U),U(U,U,U,U,U,U,U)),1*U,1*U,1*U,1*U)><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds1 :: GHC.Types.Int)
                   (x :: Language.Haskell.Tools.AST.SemaInfoTypes.ImportInfo Var.Var)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n1 :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n1
                      (Language.Haskell.Tools.AST.SemaInfoTypes.$fShowImportInfo_$cshow
                         @ Var.Var
                         Var.$fOutputableVar
                         x))
                   s) -}
a60739aeed4b637a7ebf7efe16144a70
  $s$fDataUModule_$s$fShowModuleInfo ::
    GHC.Show.Show
      (Language.Haskell.Tools.AST.SemaInfoTypes.ModuleInfo Var.Var)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Language.Haskell.Tools.AST.SemaInfoTypes.ModuleInfo Var.Var)
                  ExtensionOrganizer.$s$fDataUModule_$s$fShowModuleInfo_$cshowsPrec
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fShowModuleInfo_$cshow
                     @ Var.Var
                     Var.$fOutputableVar)
                  (Language.Haskell.Tools.AST.SemaInfoTypes.$fShowModuleInfo_$cshowList
                     @ Var.Var
                     Var.$fOutputableVar) -}
c09270b13155c2a225c91bf644ebdb0b
  $s$fDataUModule_$s$fShowModuleInfo_$cshowsPrec ::
    GHC.Types.Int
    -> Language.Haskell.Tools.AST.SemaInfoTypes.ModuleInfo Var.Var
    -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,A><S,1*U(1*U(U(U,U,U,U,U,U,U),U(U,U,U,U,U,U,U)),A,1*U,1*U,1*U,1*U)><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds1 :: GHC.Types.Int)
                   (x :: Language.Haskell.Tools.AST.SemaInfoTypes.ModuleInfo Var.Var)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n1 :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n1
                      (Language.Haskell.Tools.AST.SemaInfoTypes.$fShowModuleInfo_$cshow
                         @ Var.Var
                         Var.$fOutputableVar
                         x))
                   s) -}
12bd01d347f55eb58ff05759419d29c7
  $s$fMonadStateT ::
    GHC.Base.Monad
      (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc)
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc)
                  (ExtensionOrganizer.$s$fMonadStateT_$s$fMonadStateT_$cp1Monad @ s)
                  (ExtensionOrganizer.$s$fMonadStateT_$s$fMonadStateT_$c>>= @ s)
                  (ExtensionOrganizer.$s$fMonadStateT_$s$fMonadStateT_$c>> @ s)
                  (Control.Monad.Trans.State.Lazy.$fMonadStateT_$creturn
                     @ GhcMonad.Ghc
                     @ s
                     GhcMonad.$fMonadGhc)
                  (ExtensionOrganizer.$s$fMonadStateT_$s$fMonadStateT_$cfail @ s) -}
6a9e3baa8571ee45bfc17eea3cfc1596
  $s$fMonadStateT_$s$fMonadStateT_$c>> ::
    Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a
    -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b
    -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,C(C1(C1(U)))><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a)
                   (k :: Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> GhcMonad.Ghc (b, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b)
                   (\ (tpl :: s -> GhcMonad.Ghc (b, s)) -> tpl)
                     `cast`
                   (<s -> GhcMonad.Ghc (b, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <GhcMonad.Ghc>_R <b>_N))
                   (\ (s1 :: s) ->
                    GhcMonad.$fMonadGhc_$c>>=
                      @ (a, s)
                      @ (b, s)
                      (Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ GhcMonad.Ghc
                         @ a
                         m1
                         s1)
                      (\ (ds :: (a, s)) ->
                       Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ GhcMonad.Ghc
                         @ b
                         k
                         (case ds of wild { (,) a3 s' -> s' })))) -}
51c993695499c13909cce2eecf061050
  $s$fMonadStateT_$s$fMonadStateT_$c>>= ::
    Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a
    -> (a -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b)
    -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><L,C(C1(C1(C1(U))))><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m1 :: Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a)
                   (k :: a
                         -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> GhcMonad.Ghc (b, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc b)
                   (\ (tpl :: s -> GhcMonad.Ghc (b, s)) -> tpl)
                     `cast`
                   (<s -> GhcMonad.Ghc (b, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <GhcMonad.Ghc>_R <b>_N))
                   (\ (s1 :: s) ->
                    GhcMonad.$fMonadGhc_$c>>=
                      @ (a, s)
                      @ (b, s)
                      (Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ GhcMonad.Ghc
                         @ a
                         m1
                         s1)
                      (\ (ds :: (a, s)) ->
                       Control.Monad.Trans.State.Lazy.runStateT
                         @ s
                         @ GhcMonad.Ghc
                         @ b
                         (k (case ds of wild { (,) a3 s' -> a3 }))
                         (case ds of wild { (,) a3 s' -> s' })))) -}
a15367161ba36d9e531b1856d85b8fa6
  $s$fMonadStateT_$s$fMonadStateT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a
  {- Arity: 2, Strictness: <B,U><B,A>x, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s @ a (str :: GHC.Base.String) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> GhcMonad.Ghc (a, s))
                   @ (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc a)
                   (\ (tpl :: s -> GhcMonad.Ghc (a, s)) -> tpl)
                     `cast`
                   (<s -> GhcMonad.Ghc (a, s)>_R
                    ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <s>_N <GhcMonad.Ghc>_R <a>_N))
                   (\ (ds :: s) -> GhcMonad.$fMonadGhc_$s$dmfail @ (a, s) str)) -}
730d2c0e75c4acaa3240df9499e67874
  $s$fMonadStateT_$s$fMonadStateT_$cp1Monad ::
    GHC.Base.Applicative
      (Control.Monad.Trans.State.Lazy.StateT s GhcMonad.Ghc)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                ExtensionOrganizer.$s$fApplicativeStateT -}
8899e116ce9235df92b64f31c2adaf5d
  $s$fRefMonadswr ::
    Control.Reference.Representation.RefMonads
      (Control.Monad.Trans.State.Lazy.StateT
         (Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
         GhcMonad.Ghc)
      Data.Proxy.Proxy
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Control.Monad.Trans.State.Lazy.StateT
                       (Data.Map.Base.Map
                          GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
                       GhcMonad.Ghc)
                  @ Data.Proxy.Proxy
                  ExtensionOrganizer.$s$fRefMonadswr3
                  ExtensionOrganizer.$s$fRefMonadswr2
                  ExtensionOrganizer.$s$fRefMonadswr1
                  ExtensionOrganizer.$s$fRefMonadswr_$s$fRefMonadswr_$cp4RefMonads
                  ExtensionOrganizer.$s$fRefMonadswr_$s$fRefMonadswr_$cp5RefMonads
                  ExtensionOrganizer.$s$fRefMonadswr_$s$fRefMonadswr_$cp6RefMonads -}
c3995ab50a25dd1fa83cde847e05eaa4
  $s$fRefMonadswr1 ::
    GHC.Base.Monad
      (Control.Monad.Trans.State.Lazy.StateT
         (Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
         GhcMonad.Ghc)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (ExtensionOrganizer.$s$fMonadStateT
                   @ (Data.Map.Base.Map
                        GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])) -}
a21848d794c306aa40f2c2c7f4ac363f
  $s$fRefMonadswr2 ::
    GHC.Base.Applicative
      (Control.Monad.Trans.State.Lazy.StateT
         (Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
         GhcMonad.Ghc)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (ExtensionOrganizer.$s$fApplicativeStateT
                   @ (Data.Map.Base.Map
                        GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])) -}
545d9967f80954153922faac0b051180
  $s$fRefMonadswr3 ::
    GHC.Base.Functor
      (Control.Monad.Trans.State.Lazy.StateT
         (Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
         GhcMonad.Ghc)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                (ExtensionOrganizer.$s$fApplicativeStateT_$s$fFunctorStateT
                   @ (Data.Map.Base.Map
                        GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])) -}
b12c8f557570f4eec3e933e392eaee28
  $s$fRefMonadswr_$s$fRefMonadswr_$cp4RefMonads ::
    GHC.Base.Functor Data.Proxy.Proxy
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) Data.Proxy.$fFunctorProxy -}
e4ff3a2b8a0ffc27c8c0d2867f597c85
  $s$fRefMonadswr_$s$fRefMonadswr_$cp5RefMonads ::
    GHC.Base.Applicative Data.Proxy.Proxy
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Data.Proxy.$fApplicativeProxy -}
8d7377a3dd9422faa39c9aec5202ba58
  $s$fRefMonadswr_$s$fRefMonadswr_$cp6RefMonads ::
    GHC.Base.Monad Data.Proxy.Proxy
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) Data.Proxy.$fMonadProxy -}
df34b0b2f56bd796f7d0e085ceeada60
  $sannList1 :: [a] -> Data.Proxy.Proxy a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (eta :: [a]) -> Data.Proxy.Proxy @ * @ a) -}
279d6bc6ad7d9149364d3cc3f99cc9c6
  $slocalRefactoring1 ::
    (Language.Haskell.Tools.AST.Ann.Domain
       Language.Haskell.Tools.AST.Ann.IdDom,
     Language.Haskell.Tools.AST.SemaInfoClasses.HasModuleInfo'
       (Language.Haskell.Tools.AST.SemaInfoTypes.ModuleInfo Var.Id))
  {- Strictness: m,
     Unfolding: ((ExtensionOrganizer.$s$fDataUModule_$s$fDomaind,
                  Language.Haskell.Tools.AST.SemaInfoClasses.$fHasModuleInfo'ModuleInfo)) -}
64f1495ec4eb5e42624fd493c301e64e
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   ExtensionOrganizer.$trModule2
                   ExtensionOrganizer.$trModule1) -}
2838457efe25da23bd8077b8f1d39849
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ExtensionOrganizer"#) -}
1130cc9161c4ee4ea02f542f03a6bede
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "ht-extension-organizer-0.1.0.0-1NgBbe619AH4JExLErEUCI"#) -}
1cb98d6b8a0fedae8cf8684aaa2affb3
  collectExtensions ::
    ExtMonad.ExtDomain dom =>
    SrcLoc.RealSrcSpan
    -> Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule dom
    -> GhcMonad.Ghc
         (Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
  {- Arity: 1, Strictness: <S(SL),U(1*U,1*U)> -}
25cb32b7a0a569dea209262efe09ee7f
  collectExtensions1 ::
    Language.Haskell.Tools.AST.Ann.Ann
      Language.Haskell.Tools.AST.Representation.Modules.UModule
      Language.Haskell.Tools.AST.Ann.IdDom
      Language.Haskell.Tools.AST.Ann.SrcTemplateStage
    -> Control.Monad.Trans.State.Lazy.StateT
         (Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
         GhcMonad.Ghc
         (Language.Haskell.Tools.AST.Ann.Ann
            Language.Haskell.Tools.AST.Representation.Modules.UModule
            Language.Haskell.Tools.AST.Ann.IdDom
            Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
  {- Unfolding: (case Control.Reference.Combinators.$w&
                        @ (Control.Monad.Trans.State.Lazy.StateT
                             (Data.Map.Base.Map
                                GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
                             GhcMonad.Ghc)
                        @ Control.Reference.Representation.MU
                        @ Control.Reference.Representation.MU
                        @ Control.Reference.Representation.MU
                        @ (Language.Haskell.Tools.AST.Ann.Ann
                             Language.Haskell.Tools.AST.Representation.Modules.UModule
                             Language.Haskell.Tools.AST.Ann.IdDom
                             Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                        @ (Language.Haskell.Tools.AST.Ann.Ann
                             Language.Haskell.Tools.AST.Representation.Modules.UModule
                             Language.Haskell.Tools.AST.Ann.IdDom
                             Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                        @ (Language.Haskell.Tools.AST.Ann.AnnListG
                             Language.Haskell.Tools.AST.Representation.Decls.UDecl
                             Language.Haskell.Tools.AST.Ann.IdDom
                             Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                        @ (Language.Haskell.Tools.AST.Ann.AnnListG
                             Language.Haskell.Tools.AST.Representation.Decls.UDecl
                             Language.Haskell.Tools.AST.Ann.IdDom
                             Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                        @ (Language.Haskell.Tools.AST.Ann.Ann
                             Language.Haskell.Tools.AST.Representation.Decls.UDecl
                             Language.Haskell.Tools.AST.Ann.IdDom
                             Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                        @ (Language.Haskell.Tools.AST.Ann.Ann
                             Language.Haskell.Tools.AST.Representation.Decls.UDecl
                             Language.Haskell.Tools.AST.Ann.IdDom
                             Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                        ExtensionOrganizer.collectExtensions5
                        ExtensionOrganizer.collectExtensions4 of ww { (#,,,,,#) ww1 ww2 ww3 ww4 ww5 ww6 ->
                 ww3 ExtensionOrganizer.collectExtensions2 }) -}
5696dc45c23d4114d9597730d551ba04
  collectExtensions10 :: GHC.Fingerprint.Type.Fingerprint
  {- HasNoCafRefs,
     Unfolding: (GHC.Fingerprint.Type.Fingerprint
                   14101211046271144901##
                   14639279300041538650##) -}
4f661b7548b566b44a08c96ac3c43775
  collectExtensions11 ::
    Language.Haskell.Tools.AST.Ann.DomainWith
      Language.Haskell.Tools.AST.Representation.Modules.UModule
      Language.Haskell.Tools.AST.Ann.IdDom
  {- Unfolding: (Language.Haskell.Tools.AST.Ann.$fDomainWithed
                   @ Language.Haskell.Tools.AST.Ann.IdDom
                   @ Language.Haskell.Tools.AST.Representation.Modules.UModule
                   ExtensionOrganizer.$s$fDataModuleInfo
                     `cast`
                   (Data.Data.Data
                      (Trans
                           (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoModuleCls[0]))
                           (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                              <Language.Haskell.Tools.AST.Ann.IdDom>_N
                              (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemaInfoClassify[3])))_N))_R
                   ExtensionOrganizer.$s$fDataUModule_$s$fShowModuleInfo
                     `cast`
                   (GHC.Show.Show
                      (Trans
                           (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoModuleCls[0]))
                           (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                              <Language.Haskell.Tools.AST.Ann.IdDom>_N
                              (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemaInfoClassify[3])))_N))_R
                   ExtensionOrganizer.$s$fDataUModule_$s$fDomaind) -}
05a9560acbfa5c863c765662f56e2493
  collectExtensions2 ::
    Language.Haskell.Tools.AST.ElementTypes.Decl
      Language.Haskell.Tools.AST.Ann.IdDom
    -> Control.Monad.Trans.State.Lazy.StateT
         (Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
         GhcMonad.Ghc
         (Language.Haskell.Tools.AST.ElementTypes.Decl
            Language.Haskell.Tools.AST.Ann.IdDom)
  {- Arity: 1,
     Unfolding: (\ (x :: Language.Haskell.Tools.AST.ElementTypes.Decl
                           Language.Haskell.Tools.AST.Ann.IdDom) ->
                 let {
                   m1 :: Control.Monad.Trans.State.Lazy.StateT
                           (Data.Map.Base.Map
                              GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
                           GhcMonad.Ghc
                           (Language.Haskell.Tools.AST.ElementTypes.Decl
                              Language.Haskell.Tools.AST.Ann.IdDom)
                   = case x of ww { Language.Haskell.Tools.AST.Ann.Ann ww4 ww5 ->
                     FlexibleInstancesChecker.$wchkFlexibleInstances
                       @ Language.Haskell.Tools.AST.Ann.IdDom
                       ExtensionOrganizer.collectExtensions3
                         `cast`
                       (GHC.Classes.(%,%)
                          <Language.Haskell.Tools.AST.Ann.Domain
                             Language.Haskell.Tools.AST.Ann.IdDom>_N
                          (Language.Haskell.Tools.AST.SemaInfoClasses.HasNameInfo'
                             (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                <Language.Haskell.Tools.AST.Ann.IdDom>_N
                                (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemaInfoClassify[0])))_N)_N)_R
                       ww4
                       ww5 }
                 } in
                 (\ (s1 :: Data.Map.Base.Map
                             GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]) ->
                  let {
                    m :: GhcMonad.Ghc
                           (Language.Haskell.Tools.AST.ElementTypes.Decl
                              Language.Haskell.Tools.AST.Ann.IdDom,
                            Data.Map.Base.Map
                              GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
                    = m1
                        `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <Data.Map.Base.Map
                              GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]>_N
                           <GhcMonad.Ghc>_R
                           <Language.Haskell.Tools.AST.ElementTypes.Decl
                              Language.Haskell.Tools.AST.Ann.IdDom>_N)
                        s1
                  } in
                  (\ (s :: GhcMonad.Session)
                     (s2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                   case (m `cast`
                         (GhcMonad.N:Ghc[0]
                              <(Language.Haskell.Tools.AST.ElementTypes.Decl
                                  Language.Haskell.Tools.AST.Ann.IdDom,
                                Data.Map.Base.Map
                                  GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])>_R)
                           s)
                          `cast`
                        (GHC.Types.N:IO[0]
                             <(Language.Haskell.Tools.AST.ElementTypes.Decl
                                 Language.Haskell.Tools.AST.Ann.IdDom,
                               Data.Map.Base.Map
                                 GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])>_R)
                          s2 of ds1 { (#,#) ipv ipv1 ->
                   (((DerivingsChecker.chkDerivings
                        @ Language.Haskell.Tools.AST.Ann.IdDom
                        ExtensionOrganizer.collectExtensions3
                          `cast`
                        (GHC.Classes.(%,%)
                           <Language.Haskell.Tools.AST.Ann.Domain
                              Language.Haskell.Tools.AST.Ann.IdDom>_N
                           (Language.Haskell.Tools.AST.SemaInfoClasses.HasNameInfo'
                              (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                 <Language.Haskell.Tools.AST.Ann.IdDom>_N
                                 (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemaInfoClassify[0])))_N)_N)_R
                        (case ipv1 of wild { (,) a3 s' -> a3 }))
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <Data.Map.Base.Map
                             GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]>_N
                          <GhcMonad.Ghc>_R
                          <Language.Haskell.Tools.AST.ElementTypes.Decl
                             Language.Haskell.Tools.AST.Ann.IdDom>_N)
                       (case ipv1 of wild { (,) a3 s' -> s' }))
                      `cast`
                    (GhcMonad.N:Ghc[0]
                         <(Language.Haskell.Tools.AST.ElementTypes.Decl
                             Language.Haskell.Tools.AST.Ann.IdDom,
                           Data.Map.Base.Map
                             GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])>_R)
                      s)
                     `cast`
                   (GHC.Types.N:IO[0]
                        <(Language.Haskell.Tools.AST.ElementTypes.Decl
                            Language.Haskell.Tools.AST.Ann.IdDom,
                          Data.Map.Base.Map
                            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])>_R)
                     ipv })
                    `cast`
                  (Trans
                       (<GhcMonad.Session>_R
                        ->_R Sym (GHC.Types.N:IO[0]
                                      <(Language.Haskell.Tools.AST.ElementTypes.Decl
                                          Language.Haskell.Tools.AST.Ann.IdDom,
                                        Data.Map.Base.Map
                                          GHC.LanguageExtensions.Type.Extension
                                          [SrcLoc.SrcSpan])>_R))
                       (Sym (GhcMonad.N:Ghc[0]
                                 <(Language.Haskell.Tools.AST.ElementTypes.Decl
                                     Language.Haskell.Tools.AST.Ann.IdDom,
                                   Data.Map.Base.Map
                                     GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])>_R))))
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <Data.Map.Base.Map
                              GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]>_N
                           <GhcMonad.Ghc>_R
                           <Language.Haskell.Tools.AST.ElementTypes.Decl
                              Language.Haskell.Tools.AST.Ann.IdDom>_N))) -}
a59abbc27385a6ca8a1779a9696cf4d2
  collectExtensions3 ::
    (Language.Haskell.Tools.AST.Ann.Domain
       Language.Haskell.Tools.AST.Ann.IdDom,
     Language.Haskell.Tools.AST.SemaInfoClasses.HasNameInfo'
       (Language.Haskell.Tools.AST.Ann.SemanticInfo'
          Language.Haskell.Tools.AST.Ann.IdDom
          Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
  {- Strictness: m,
     Unfolding: ((ExtensionOrganizer.$s$fDataUModule_$s$fDomaind,
                  Language.Haskell.Tools.AST.SemaInfoClasses.$fHasIdInfo'CNameInfo_$csemanticsName
                    `cast`
                  (Sym (Language.Haskell.Tools.AST.SemaInfoClasses.N:HasNameInfo'[0]
                            (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoNameCls[0]))))) -}
254313dd81e29a29ce71092415573c51
  collectExtensions4 ::
    Control.Reference.Representation.Reference
      (Control.Monad.Trans.State.Lazy.StateT
         (Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
         GhcMonad.Ghc)
      Control.Reference.Representation.MU
      Control.Reference.Representation.MU
      Control.Reference.Representation.MU
      (Language.Haskell.Tools.AST.Ann.AnnListG
         Language.Haskell.Tools.AST.Representation.Decls.UDecl
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
      (Language.Haskell.Tools.AST.Ann.AnnListG
         Language.Haskell.Tools.AST.Representation.Decls.UDecl
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
      (Language.Haskell.Tools.AST.Ann.Ann
         Language.Haskell.Tools.AST.Representation.Decls.UDecl
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
      (Language.Haskell.Tools.AST.Ann.Ann
         Language.Haskell.Tools.AST.Representation.Decls.UDecl
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
  {- Unfolding: (case Language.Haskell.Tools.AST.Ann.$wannList
                        @ Language.Haskell.Tools.AST.Representation.Decls.UDecl
                        @ Language.Haskell.Tools.AST.Ann.IdDom
                        @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                        @ (Control.Monad.Trans.State.Lazy.StateT
                             (Data.Map.Base.Map
                                GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
                             GhcMonad.Ghc)
                        @ Control.Reference.Representation.MU
                        ExtensionOrganizer.$s$fRefMonadswr
                        ExtensionOrganizer.$sannList1
                          `cast`
                        (Sym (Control.Instances.Morph.N:Morph[0]
                                  <[]>_N
                                  <Data.Proxy.Proxy>_N)) of ww { (#,,,,,#) ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Control.Reference.Representation.Reference
                   @ (Control.Monad.Trans.State.Lazy.StateT
                        (Data.Map.Base.Map
                           GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
                        GhcMonad.Ghc)
                   @ Control.Reference.Representation.MU
                   @ Control.Reference.Representation.MU
                   @ Control.Reference.Representation.MU
                   @ (Language.Haskell.Tools.AST.Ann.AnnListG
                        Language.Haskell.Tools.AST.Representation.Decls.UDecl
                        Language.Haskell.Tools.AST.Ann.IdDom
                        Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                   @ (Language.Haskell.Tools.AST.Ann.AnnListG
                        Language.Haskell.Tools.AST.Representation.Decls.UDecl
                        Language.Haskell.Tools.AST.Ann.IdDom
                        Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                   @ (Language.Haskell.Tools.AST.Ann.Ann
                        Language.Haskell.Tools.AST.Representation.Decls.UDecl
                        Language.Haskell.Tools.AST.Ann.IdDom
                        Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                   @ (Language.Haskell.Tools.AST.Ann.Ann
                        Language.Haskell.Tools.AST.Representation.Decls.UDecl
                        Language.Haskell.Tools.AST.Ann.IdDom
                        Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6 }) -}
67ee17147e7642f25517474ccac47d06
  collectExtensions5 ::
    Control.Reference.Representation.Reference
      (Control.Monad.Trans.State.Lazy.StateT
         (Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
         GhcMonad.Ghc)
      Control.Reference.Representation.MU
      Control.Reference.Representation.MU
      Control.Reference.Representation.MU
      (Language.Haskell.Tools.AST.Ann.Ann
         Language.Haskell.Tools.AST.Representation.Modules.UModule
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
      (Language.Haskell.Tools.AST.Ann.Ann
         Language.Haskell.Tools.AST.Representation.Modules.UModule
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
      (Language.Haskell.Tools.AST.Ann.AnnListG
         Language.Haskell.Tools.AST.Representation.Decls.UDecl
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
      (Language.Haskell.Tools.AST.Ann.AnnListG
         Language.Haskell.Tools.AST.Representation.Decls.UDecl
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
  {- Unfolding: (case Language.Haskell.Tools.AST.References.$wmodDecl
                        @ Language.Haskell.Tools.AST.Ann.IdDom
                        @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                        @ (Control.Monad.Trans.State.Lazy.StateT
                             (Data.Map.Base.Map
                                GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
                             GhcMonad.Ghc)
                        @ Control.Reference.Representation.MU
                        ExtensionOrganizer.$s$fRefMonadswr of ww { (#,,,,,#) ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Control.Reference.Representation.Reference
                   @ (Control.Monad.Trans.State.Lazy.StateT
                        (Data.Map.Base.Map
                           GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
                        GhcMonad.Ghc)
                   @ Control.Reference.Representation.MU
                   @ Control.Reference.Representation.MU
                   @ Control.Reference.Representation.MU
                   @ (Language.Haskell.Tools.AST.Ann.Ann
                        Language.Haskell.Tools.AST.Representation.Modules.UModule
                        Language.Haskell.Tools.AST.Ann.IdDom
                        Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                   @ (Language.Haskell.Tools.AST.Ann.Ann
                        Language.Haskell.Tools.AST.Representation.Modules.UModule
                        Language.Haskell.Tools.AST.Ann.IdDom
                        Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                   @ (Language.Haskell.Tools.AST.Ann.AnnListG
                        Language.Haskell.Tools.AST.Representation.Decls.UDecl
                        Language.Haskell.Tools.AST.Ann.IdDom
                        Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                   @ (Language.Haskell.Tools.AST.Ann.AnnListG
                        Language.Haskell.Tools.AST.Representation.Decls.UDecl
                        Language.Haskell.Tools.AST.Ann.IdDom
                        Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                   ww1
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6 }) -}
6c87b390802f56f8562c5463ba8af980
  collectExtensions6 ::
    SrcLoc.RealSrcSpan
    -> Language.Haskell.Tools.AST.Ann.Ann
         Language.Haskell.Tools.AST.Representation.Modules.UModule
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SrcTemplateStage
    -> Control.Monad.Trans.State.Lazy.StateT
         (Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
         GhcMonad.Ghc
         (Language.Haskell.Tools.AST.Ann.Ann
            Language.Haskell.Tools.AST.Representation.Modules.UModule
            Language.Haskell.Tools.AST.Ann.IdDom
            Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
  {- Unfolding: (RecordWildCardsChecker.chkRecordWildCards
                   @ Language.Haskell.Tools.AST.Ann.IdDom
                   @ (Language.Haskell.Tools.AST.Ann.Ann
                        Language.Haskell.Tools.AST.Representation.Modules.UModule)
                   @~ (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoDefaultCls[0])
                   Language.Haskell.Tools.AST.SemaInfoTypes.$fShowImplicitFieldInfo
                     `cast`
                   (GHC.Show.Show
                      (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoWildcardCls[0])))_R
                   ExtensionOrganizer.$s$fDataUModule_$s$fShowModuleInfo
                     `cast`
                   (GHC.Show.Show
                      (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoModuleCls[0])))_R
                   ExtensionOrganizer.$s$fDataUModule_$s$fShowImportInfo
                     `cast`
                   (GHC.Show.Show
                      (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoImportCls[0])))_R
                   Language.Haskell.Tools.AST.SemaInfoTypes.$fShowScopeInfo
                     `cast`
                   (GHC.Show.Show
                      (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoExprCls[0])))_R
                   Language.Haskell.Tools.AST.SemaInfoTypes.$fShowCNameInfo
                     `cast`
                   (GHC.Show.Show
                      (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoNameCls[0])))_R
                   ExtensionOrganizer.collectExtensions7
                   Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImplicitFieldInfo
                     `cast`
                   (Data.Data.Data
                      (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoWildcardCls[0])))_R
                   ExtensionOrganizer.$s$fDataModuleInfo
                     `cast`
                   (Data.Data.Data
                      (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoModuleCls[0])))_R
                   ExtensionOrganizer.$s$fDataImportInfo
                     `cast`
                   (Data.Data.Data
                      (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoImportCls[0])))_R
                   Language.Haskell.Tools.AST.SemaInfoTypes.$fDataScopeInfo
                     `cast`
                   (Data.Data.Data
                      (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoExprCls[0])))_R
                   Language.Haskell.Tools.AST.SemaInfoTypes.$fDataCNameInfo
                     `cast`
                   (Data.Data.Data
                      (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoNameCls[0])))_R
                   Language.Haskell.Tools.AST.Ann.$fDataIdDom) -}
1396bd9c1ab4ff72dc536bc9fd231633
  collectExtensions7 ::
    Data.Data.Data
      (Language.Haskell.Tools.AST.Ann.Ann
         Language.Haskell.Tools.AST.Representation.Modules.UModule
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
  {- Unfolding: (Language.Haskell.Tools.AST.Instances.Data.$fDataAnn
                   @ Language.Haskell.Tools.AST.Representation.Modules.UModule
                   @ Language.Haskell.Tools.AST.Ann.IdDom
                   @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                   ExtensionOrganizer.collectExtensions11
                   Language.Haskell.Tools.Transform.SourceTemplate.$fSourceInfoSrcTemplateStage
                   ExtensionOrganizer.collectExtensions8
                     `cast`
                   (Sym (Data.Typeable.Internal.N:Typeable[0]
                             <GHC.Types.* -> GHC.Types.* -> *>_N
                             <Language.Haskell.Tools.AST.Representation.Modules.UModule>_N))
                   ExtensionOrganizer.$s$fDataUModule) -}
96f5f85a5f3b20c49a9d3fd0213518cc
  collectExtensions8 ::
    GHC.Prim.Proxy#
      Language.Haskell.Tools.AST.Representation.Modules.UModule
    -> Data.Typeable.Internal.TypeRep
  {- Arity: 1, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (wild :: GHC.Prim.Proxy#
                              Language.Haskell.Tools.AST.Representation.Modules.UModule) ->
                 ExtensionOrganizer.collectExtensions9) -}
de6ae1cb892b6f113a2df4ce6f76118a
  collectExtensions9 :: Data.Typeable.Internal.TypeRep
  {- Unfolding: (case Data.Typeable.Internal.typeRepFingerprints
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[]
                           @ Data.Typeable.Internal.TypeRep) of kt_fps { DEFAULT ->
                 case GHC.Fingerprint.fingerprintFingerprints
                        (GHC.Types.:
                           @ GHC.Fingerprint.Type.Fingerprint
                           ExtensionOrganizer.collectExtensions10
                           kt_fps) of dt { GHC.Fingerprint.Type.Fingerprint dt1 dt2 ->
                 Data.Typeable.Internal.TypeRep
                   dt1
                   dt2
                   Language.Haskell.Tools.AST.Representation.Modules.$tcUModule
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                   (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } }) -}
3f875dce769292bc6c6ab60ce735a571
  collectExtensions_$scollectExtensions ::
    SrcLoc.RealSrcSpan
    -> Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
         Language.Haskell.Tools.AST.Ann.IdDom
    -> GhcMonad.Ghc
         (Data.Map.Base.Map
            GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: (\ (sp :: SrcLoc.RealSrcSpan)
                   (eta :: Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                             Language.Haskell.Tools.AST.Ann.IdDom) ->
                 let {
                   m :: GhcMonad.Ghc
                          (Language.Haskell.Tools.AST.Ann.Ann
                             Language.Haskell.Tools.AST.Representation.Modules.UModule
                             Language.Haskell.Tools.AST.Ann.IdDom
                             Language.Haskell.Tools.AST.Ann.SrcTemplateStage,
                           Data.Map.Base.Map
                             GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
                   = (ExtensionOrganizer.collectExtensions6 sp eta)
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <Data.Map.Base.Map
                             GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]>_N
                          <GhcMonad.Ghc>_R
                          <Language.Haskell.Tools.AST.Ann.Ann
                             Language.Haskell.Tools.AST.Representation.Modules.UModule
                             Language.Haskell.Tools.AST.Ann.IdDom
                             Language.Haskell.Tools.AST.Ann.SrcTemplateStage>_N)
                       (Data.Map.Base.Tip
                          @ GHC.LanguageExtensions.Type.Extension
                          @ [SrcLoc.SrcSpan])
                 } in
                 (\ (s :: GhcMonad.Session)
                    (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                  case (m `cast`
                        (GhcMonad.N:Ghc[0]
                             <(Language.Haskell.Tools.AST.Ann.Ann
                                 Language.Haskell.Tools.AST.Representation.Modules.UModule
                                 Language.Haskell.Tools.AST.Ann.IdDom
                                 Language.Haskell.Tools.AST.Ann.SrcTemplateStage,
                               Data.Map.Base.Map
                                 GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])>_R)
                          s)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <(Language.Haskell.Tools.AST.Ann.Ann
                                Language.Haskell.Tools.AST.Representation.Modules.UModule
                                Language.Haskell.Tools.AST.Ann.IdDom
                                Language.Haskell.Tools.AST.Ann.SrcTemplateStage,
                              Data.Map.Base.Map
                                GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])>_R)
                         s1 of ds1 { (#,#) ipv ipv1 ->
                  case (((ExtensionOrganizer.collectExtensions1
                            (case ipv1 of wild { (,) a3 s' -> a3 }))
                           `cast`
                         (Control.Monad.Trans.State.Lazy.N:StateT[0]
                              <Data.Map.Base.Map
                                 GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]>_N
                              <GhcMonad.Ghc>_R
                              <Language.Haskell.Tools.AST.Ann.Ann
                                 Language.Haskell.Tools.AST.Representation.Modules.UModule
                                 Language.Haskell.Tools.AST.Ann.IdDom
                                 Language.Haskell.Tools.AST.Ann.SrcTemplateStage>_N)
                           (case ipv1 of wild { (,) a3 s' -> s' }))
                          `cast`
                        (GhcMonad.N:Ghc[0]
                             <(Language.Haskell.Tools.AST.Ann.Ann
                                 Language.Haskell.Tools.AST.Representation.Modules.UModule
                                 Language.Haskell.Tools.AST.Ann.IdDom
                                 Language.Haskell.Tools.AST.Ann.SrcTemplateStage,
                               Data.Map.Base.Map
                                 GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])>_R)
                          s)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <(Language.Haskell.Tools.AST.Ann.Ann
                                Language.Haskell.Tools.AST.Representation.Modules.UModule
                                Language.Haskell.Tools.AST.Ann.IdDom
                                Language.Haskell.Tools.AST.Ann.SrcTemplateStage,
                              Data.Map.Base.Map
                                GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])>_R)
                         ipv of ds2 { (#,#) ipv2 ipv3 ->
                  case ipv3 of wild { (,) ds exts -> (# ipv2, exts #) } } })
                   `cast`
                 (Trans
                      (<GhcMonad.Session>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <Data.Map.Base.Map
                                        GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]>_R))
                      (Sym (GhcMonad.N:Ghc[0]
                                <Data.Map.Base.Map
                                   GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]>_R)))) -}
c75b77376556d3030aadc57dceab5687
  organizeExtensions ::
    ExtMonad.ExtDomain dom =>
    SrcLoc.RealSrcSpan
    -> Language.Haskell.Tools.Refactor.RefactorBase.LocalRefactoring
         dom
  {- Arity: 3,
     Strictness: <S(S(LLS(S)LLLLLLLLLL)L),U(U(U,U,U(U),U,U,U,U,U,U,U,U,U,U),U)><L,U><L,U>,
     Unfolding: (\ @ dom
                   ($d(%,%) :: ExtMonad.ExtDomain dom)
                   (eta :: SrcLoc.RealSrcSpan)
                   (eta1 :: Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                              dom) ->
                 case GHC.Types.HEq_sc
                        @ *
                        @ *
                        @ (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                             dom Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls)
                        @ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo
                        (Language.Haskell.Tools.AST.Ann.$p3Domain
                           @ dom
                           (GHC.Classes.$p1(%,%)
                              @ (Language.Haskell.Tools.AST.Ann.Domain dom)
                              @ (Language.Haskell.Tools.AST.SemaInfoClasses.HasNameInfo'
                                   (Language.Haskell.Tools.AST.Ann.SemanticInfo
                                      dom
                                      Language.Haskell.Tools.AST.Representation.Names.UQualifiedName))
                              $d(%,%)))
                          `cast`
                        (Data.Type.Equality.N:~[0]
                             <*>_N <Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                      dom
                                      Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls>_N <Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo>_N) of cobox0 { DEFAULT ->
                 let {
                   x :: GhcMonad.Ghc
                          (Data.Map.Base.Map
                             GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
                   = ExtensionOrganizer.collectExtensions @ dom $d(%,%) eta eta1
                 } in
                 (\ (r1 :: Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                             dom)
                    (eta2 :: GhcMonad.Session)
                    (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                  case (x `cast`
                        (GhcMonad.N:Ghc[0]
                             <Data.Map.Base.Map
                                GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]>_R)
                          eta2)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Map.Base.Map
                               GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]>_R)
                         eta3 of ds1 { (#,#) ipv ipv1 ->
                  case (((ExtensionOrganizer.organizeExtensions4
                            @ dom
                            (ExtensionOrganizer.organizeExtensions3 @ dom)
                              `cast`
                            (Trans
                                 (<Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx dom>_R
                                  ->_R Trans
                                           (<GhcMonad.Session>_R
                                            ->_R Sym (GHC.Types.N:IO[0]
                                                          <Data.Either.Either
                                                             [GHC.Types.Char]
                                                             ((),
                                                              [Data.Either.Either
                                                                 Name.Name
                                                                 (SrcLoc.SrcSpan, GHC.Base.String,
                                                                  GHC.Base.String)])>_R))
                                           (Trans
                                                (Sym (GhcMonad.N:Ghc[0]
                                                          <Data.Either.Either
                                                             [GHC.Types.Char]
                                                             ((),
                                                              [Data.Either.Either
                                                                 Name.Name
                                                                 (SrcLoc.SrcSpan, GHC.Base.String,
                                                                  GHC.Base.String)])>_R))
                                                (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <[GHC.Types.Char]>_N
                                                          <GhcMonad.Ghc>_R
                                                          <((),
                                                            [Data.Either.Either
                                                               Name.Name
                                                               (SrcLoc.SrcSpan, GHC.Base.String,
                                                                GHC.Base.String)])>_N))))
                                 (Trans
                                      (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                <*>_N
                                                <Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                                                   dom>_R
                                                <Control.Monad.Trans.Except.ExceptT
                                                   GHC.Base.String GhcMonad.Ghc>_R
                                                <((),
                                                  [Data.Either.Either
                                                     Name.Name
                                                     (SrcLoc.SrcSpan, GHC.Base.String,
                                                      GHC.Base.String)])>_N))
                                      (Trans
                                           (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                     <[Data.Either.Either
                                                         Name.Name
                                                         (SrcLoc.SrcSpan, GHC.Base.String,
                                                          GHC.Base.String)]>_N
                                                     <Control.Monad.Trans.Reader.ReaderT
                                                        (Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                                                           dom)
                                                        (Control.Monad.Trans.Except.ExceptT
                                                           GHC.Base.String GhcMonad.Ghc)>_R
                                                     <()>_N))
                                           (Sym (Language.Haskell.Tools.Refactor.RefactorBase.N:LocalRefactorT[0]
                                                     <dom>_N
                                                     <Control.Monad.Trans.Except.ExceptT
                                                        GHC.Base.String GhcMonad.Ghc>_R) <()>_N))))
                            ipv1)
                           `cast`
                         (Trans
                              (Language.Haskell.Tools.Refactor.RefactorBase.N:LocalRefactorT[0]
                                   <dom>_N
                                   <Control.Monad.Trans.Except.ExceptT
                                      GHC.Base.String GhcMonad.Ghc>_R <()>_N)
                              (Trans
                                   (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                        <[Data.Either.Either
                                            Name.Name
                                            (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)]>_N
                                        <Control.Monad.Trans.Reader.ReaderT
                                           (Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                                              dom)
                                           (Control.Monad.Trans.Except.ExceptT
                                              GHC.Base.String GhcMonad.Ghc)>_R
                                        <()>_N)
                                   (Control.Monad.Trans.Reader.N:ReaderT[0]
                                        <*>_N
                                        <Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                                           dom>_R
                                        <Control.Monad.Trans.Except.ExceptT
                                           GHC.Base.String GhcMonad.Ghc>_R
                                        <((),
                                          [Data.Either.Either
                                             Name.Name
                                             (SrcLoc.SrcSpan, GHC.Base.String,
                                              GHC.Base.String)])>_N)))
                           r1)
                          `cast`
                        (Trans
                             (Control.Monad.Trans.Except.N:ExceptT[0]
                                  <[GHC.Types.Char]>_N
                                  <GhcMonad.Ghc>_R
                                  <((),
                                    [Data.Either.Either
                                       Name.Name
                                       (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)])>_N)
                             (GhcMonad.N:Ghc[0]
                                  <Data.Either.Either
                                     [GHC.Types.Char]
                                     ((),
                                      [Data.Either.Either
                                         Name.Name
                                         (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)])>_R))
                          eta2)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Either.Either
                               [GHC.Types.Char]
                               ((),
                                [Data.Either.Either
                                   Name.Name
                                   (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)])>_R)
                         ipv of ds2 { (#,#) ipv2 ipv3 ->
                  case ipv3 of wild {
                    Data.Either.Left e1
                    -> (# ipv2,
                          Data.Either.Left
                            @ [GHC.Types.Char]
                            @ (Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule dom,
                               [Data.Either.Either
                                  Name.Name (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)])
                            e1 #)
                    Data.Either.Right x1
                    -> (# ipv2,
                          Data.Either.Right
                            @ [GHC.Types.Char]
                            @ (Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule dom,
                               [Data.Either.Either
                                  Name.Name (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)])
                            (eta1, case x1 of wild1 { (,) a3 w2 -> w2 }) #) } } })
                   `cast`
                 (Trans
                      (<Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx dom>_R
                       ->_R Trans
                                (<GhcMonad.Session>_R
                                 ->_R Sym (GHC.Types.N:IO[0]
                                               <Data.Either.Either
                                                  [GHC.Types.Char]
                                                  (Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                                                     dom,
                                                   [Data.Either.Either
                                                      Name.Name
                                                      (SrcLoc.SrcSpan, GHC.Base.String,
                                                       GHC.Base.String)])>_R))
                                (Trans
                                     (Sym (GhcMonad.N:Ghc[0]
                                               <Data.Either.Either
                                                  [GHC.Types.Char]
                                                  (Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                                                     dom,
                                                   [Data.Either.Either
                                                      Name.Name
                                                      (SrcLoc.SrcSpan, GHC.Base.String,
                                                       GHC.Base.String)])>_R))
                                     (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                               <[GHC.Types.Char]>_N
                                               <GhcMonad.Ghc>_R
                                               <(Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                                                   dom,
                                                 [Data.Either.Either
                                                    Name.Name
                                                    (SrcLoc.SrcSpan, GHC.Base.String,
                                                     GHC.Base.String)])>_N))))
                      (Trans
                           (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                     <*>_N
                                     <Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                                        dom>_R
                                     <Control.Monad.Trans.Except.ExceptT
                                        GHC.Base.String GhcMonad.Ghc>_R
                                     <(Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                                         dom,
                                       [Data.Either.Either
                                          Name.Name
                                          (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)])>_N))
                           (Trans
                                (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                          <[Data.Either.Either
                                              Name.Name
                                              (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)]>_N
                                          <Control.Monad.Trans.Reader.ReaderT
                                             (Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                                                dom)
                                             (Control.Monad.Trans.Except.ExceptT
                                                GHC.Base.String GhcMonad.Ghc)>_R
                                          <Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                                             dom>_N))
                                (Sym (Language.Haskell.Tools.Refactor.RefactorBase.N:LocalRefactorT[0]
                                          <dom>_N
                                          <Control.Monad.Trans.Except.ExceptT
                                             GHC.Base.String
                                             GhcMonad.Ghc>_R) <Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                                                                 dom>_N)))) }) -}
c65a235f0a151c6ff4c95d8f4b0925f1
  organizeExtensions1 ::
    Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
      Language.Haskell.Tools.AST.Ann.IdDom
    -> GhcMonad.Session
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            [GHC.Types.Char]
            ((),
             [Data.Either.Either
                Name.Name (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)]) #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><S,U>,
     Unfolding: InlineRule (3, True, True)
                (\ (eta1 :: Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                              Language.Haskell.Tools.AST.Ann.IdDom)
                   (eta :: GhcMonad.Session)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# eta2, ExtensionOrganizer.organizeExtensions_a1 #)) -}
48ec9a81f5fb7db1205a6eff63e82c25
  organizeExtensions2 ::
    ((),
     [Data.Either.Either
        Name.Name (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)])
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((GHC.Tuple.(),
                  GHC.Types.[]
                    @ (Data.Either.Either
                         Name.Name (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)))) -}
38e7095fa3ec98bb41afceb880616de3
  organizeExtensions3 ::
    Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx dom
    -> GhcMonad.Session
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Either.Either
            [GHC.Types.Char]
            ((),
             [Data.Either.Either
                Name.Name (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)]) #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><S,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ dom
                   (eta1 :: Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                              dom)
                   (eta :: GhcMonad.Session)
                   (eta2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# eta2, ExtensionOrganizer.organizeExtensions_a1 #)) -}
0bd2e6ce079fec63f83c26abfbcd4ae6
  organizeExtensions4 ::
    Language.Haskell.Tools.Refactor.RefactorBase.LocalRefactorT
      dom Language.Haskell.Tools.Refactor.RefactorBase.Refactor ()
    -> Data.Map.Base.Map
         GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]
    -> Language.Haskell.Tools.Refactor.RefactorBase.LocalRefactorT
         dom Language.Haskell.Tools.Refactor.RefactorBase.Refactor ()
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
2db10ed27c65e11965680bb7d193a00d
  organizeExtensions_$sorganizeExtensions ::
    SrcLoc.RealSrcSpan
    -> Language.Haskell.Tools.Refactor.RefactorBase.LocalRefactoring
         Language.Haskell.Tools.AST.Ann.IdDom
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: (\ (eta :: SrcLoc.RealSrcSpan)
                   (eta1 :: Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                              Language.Haskell.Tools.AST.Ann.IdDom) ->
                 let {
                   x :: GhcMonad.Ghc
                          (Data.Map.Base.Map
                             GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan])
                   = ExtensionOrganizer.collectExtensions_$scollectExtensions eta eta1
                 } in
                 (\ (r1 :: Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                             Language.Haskell.Tools.AST.Ann.IdDom)
                    (eta2 :: GhcMonad.Session)
                    (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                  case (x `cast`
                        (GhcMonad.N:Ghc[0]
                             <Data.Map.Base.Map
                                GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]>_R)
                          eta2)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Map.Base.Map
                               GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]>_R)
                         eta3 of ds1 { (#,#) ipv ipv1 ->
                  case (((ExtensionOrganizer.organizeExtensions_go10
                            ExtensionOrganizer.organizeExtensions1
                              `cast`
                            (Trans
                                 (<Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                                     Language.Haskell.Tools.AST.Ann.IdDom>_R
                                  ->_R Trans
                                           (<GhcMonad.Session>_R
                                            ->_R Sym (GHC.Types.N:IO[0]
                                                          <Data.Either.Either
                                                             [GHC.Types.Char]
                                                             ((),
                                                              [Data.Either.Either
                                                                 Name.Name
                                                                 (SrcLoc.SrcSpan, GHC.Base.String,
                                                                  GHC.Base.String)])>_R))
                                           (Trans
                                                (Sym (GhcMonad.N:Ghc[0]
                                                          <Data.Either.Either
                                                             [GHC.Types.Char]
                                                             ((),
                                                              [Data.Either.Either
                                                                 Name.Name
                                                                 (SrcLoc.SrcSpan, GHC.Base.String,
                                                                  GHC.Base.String)])>_R))
                                                (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                          <[GHC.Types.Char]>_N
                                                          <GhcMonad.Ghc>_R
                                                          <((),
                                                            [Data.Either.Either
                                                               Name.Name
                                                               (SrcLoc.SrcSpan, GHC.Base.String,
                                                                GHC.Base.String)])>_N))))
                                 (Trans
                                      (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                                <*>_N
                                                <Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                                                   Language.Haskell.Tools.AST.Ann.IdDom>_R
                                                <Control.Monad.Trans.Except.ExceptT
                                                   GHC.Base.String GhcMonad.Ghc>_R
                                                <((),
                                                  [Data.Either.Either
                                                     Name.Name
                                                     (SrcLoc.SrcSpan, GHC.Base.String,
                                                      GHC.Base.String)])>_N))
                                      (Trans
                                           (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                     <[Data.Either.Either
                                                         Name.Name
                                                         (SrcLoc.SrcSpan, GHC.Base.String,
                                                          GHC.Base.String)]>_N
                                                     <Control.Monad.Trans.Reader.ReaderT
                                                        (Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                                                           Language.Haskell.Tools.AST.Ann.IdDom)
                                                        (Control.Monad.Trans.Except.ExceptT
                                                           GHC.Base.String GhcMonad.Ghc)>_R
                                                     <()>_N))
                                           (Sym (Language.Haskell.Tools.Refactor.RefactorBase.N:LocalRefactorT[0]
                                                     <Language.Haskell.Tools.AST.Ann.IdDom>_N
                                                     <Control.Monad.Trans.Except.ExceptT
                                                        GHC.Base.String GhcMonad.Ghc>_R) <()>_N))))
                            ipv1)
                           `cast`
                         (Trans
                              (Language.Haskell.Tools.Refactor.RefactorBase.N:LocalRefactorT[0]
                                   <Language.Haskell.Tools.AST.Ann.IdDom>_N
                                   <Control.Monad.Trans.Except.ExceptT
                                      GHC.Base.String GhcMonad.Ghc>_R <()>_N)
                              (Trans
                                   (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                        <[Data.Either.Either
                                            Name.Name
                                            (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)]>_N
                                        <Control.Monad.Trans.Reader.ReaderT
                                           (Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                                              Language.Haskell.Tools.AST.Ann.IdDom)
                                           (Control.Monad.Trans.Except.ExceptT
                                              GHC.Base.String GhcMonad.Ghc)>_R
                                        <()>_N)
                                   (Control.Monad.Trans.Reader.N:ReaderT[0]
                                        <*>_N
                                        <Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                                           Language.Haskell.Tools.AST.Ann.IdDom>_R
                                        <Control.Monad.Trans.Except.ExceptT
                                           GHC.Base.String GhcMonad.Ghc>_R
                                        <((),
                                          [Data.Either.Either
                                             Name.Name
                                             (SrcLoc.SrcSpan, GHC.Base.String,
                                              GHC.Base.String)])>_N)))
                           r1)
                          `cast`
                        (Trans
                             (Control.Monad.Trans.Except.N:ExceptT[0]
                                  <[GHC.Types.Char]>_N
                                  <GhcMonad.Ghc>_R
                                  <((),
                                    [Data.Either.Either
                                       Name.Name
                                       (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)])>_N)
                             (GhcMonad.N:Ghc[0]
                                  <Data.Either.Either
                                     [GHC.Types.Char]
                                     ((),
                                      [Data.Either.Either
                                         Name.Name
                                         (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)])>_R))
                          eta2)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Data.Either.Either
                               [GHC.Types.Char]
                               ((),
                                [Data.Either.Either
                                   Name.Name
                                   (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)])>_R)
                         ipv of ds2 { (#,#) ipv2 ipv3 ->
                  case ipv3 of wild {
                    Data.Either.Left e1
                    -> (# ipv2,
                          Data.Either.Left
                            @ [GHC.Types.Char]
                            @ (Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                                 Language.Haskell.Tools.AST.Ann.IdDom,
                               [Data.Either.Either
                                  Name.Name (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)])
                            e1 #)
                    Data.Either.Right x1
                    -> (# ipv2,
                          Data.Either.Right
                            @ [GHC.Types.Char]
                            @ (Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                                 Language.Haskell.Tools.AST.Ann.IdDom,
                               [Data.Either.Either
                                  Name.Name (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)])
                            (eta1, case x1 of wild1 { (,) a3 w2 -> w2 }) #) } } })
                   `cast`
                 (Trans
                      (<Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                          Language.Haskell.Tools.AST.Ann.IdDom>_R
                       ->_R Trans
                                (<GhcMonad.Session>_R
                                 ->_R Sym (GHC.Types.N:IO[0]
                                               <Data.Either.Either
                                                  [GHC.Types.Char]
                                                  (Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                                                     Language.Haskell.Tools.AST.Ann.IdDom,
                                                   [Data.Either.Either
                                                      Name.Name
                                                      (SrcLoc.SrcSpan, GHC.Base.String,
                                                       GHC.Base.String)])>_R))
                                (Trans
                                     (Sym (GhcMonad.N:Ghc[0]
                                               <Data.Either.Either
                                                  [GHC.Types.Char]
                                                  (Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                                                     Language.Haskell.Tools.AST.Ann.IdDom,
                                                   [Data.Either.Either
                                                      Name.Name
                                                      (SrcLoc.SrcSpan, GHC.Base.String,
                                                       GHC.Base.String)])>_R))
                                     (Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                               <[GHC.Types.Char]>_N
                                               <GhcMonad.Ghc>_R
                                               <(Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                                                   Language.Haskell.Tools.AST.Ann.IdDom,
                                                 [Data.Either.Either
                                                    Name.Name
                                                    (SrcLoc.SrcSpan, GHC.Base.String,
                                                     GHC.Base.String)])>_N))))
                      (Trans
                           (Sym (Control.Monad.Trans.Reader.N:ReaderT[0]
                                     <*>_N
                                     <Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                                        Language.Haskell.Tools.AST.Ann.IdDom>_R
                                     <Control.Monad.Trans.Except.ExceptT
                                        GHC.Base.String GhcMonad.Ghc>_R
                                     <(Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                                         Language.Haskell.Tools.AST.Ann.IdDom,
                                       [Data.Either.Either
                                          Name.Name
                                          (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)])>_N))
                           (Trans
                                (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                          <[Data.Either.Either
                                              Name.Name
                                              (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)]>_N
                                          <Control.Monad.Trans.Reader.ReaderT
                                             (Language.Haskell.Tools.Refactor.RefactorBase.RefactorCtx
                                                Language.Haskell.Tools.AST.Ann.IdDom)
                                             (Control.Monad.Trans.Except.ExceptT
                                                GHC.Base.String GhcMonad.Ghc)>_R
                                          <Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                                             Language.Haskell.Tools.AST.Ann.IdDom>_N))
                                (Sym (Language.Haskell.Tools.Refactor.RefactorBase.N:LocalRefactorT[0]
                                          <Language.Haskell.Tools.AST.Ann.IdDom>_N
                                          <Control.Monad.Trans.Except.ExceptT
                                             GHC.Base.String
                                             GhcMonad.Ghc>_R) <Language.Haskell.Tools.Refactor.RefactorBase.UnnamedModule
                                                                 Language.Haskell.Tools.AST.Ann.IdDom>_N))))) -}
ad1fe57fe8ec2aefaea20b9e85a9c9e4
  organizeExtensions_a1 ::
    Data.Either.Either
      [GHC.Types.Char]
      ((),
       [Data.Either.Either
          Name.Name (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)])
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (Data.Either.Right
                   @ [GHC.Types.Char]
                   @ ((),
                      [Data.Either.Either
                         Name.Name (SrcLoc.SrcSpan, GHC.Base.String, GHC.Base.String)])
                   ExtensionOrganizer.organizeExtensions2) -}
7a42a3d3c20ec0a1d99293ecca0716cd
  organizeExtensions_go10 ::
    Language.Haskell.Tools.Refactor.RefactorBase.LocalRefactorT
      Language.Haskell.Tools.AST.Ann.IdDom
      Language.Haskell.Tools.Refactor.RefactorBase.Refactor
      ()
    -> Data.Map.Base.Map
         GHC.LanguageExtensions.Type.Extension [SrcLoc.SrcSpan]
    -> Language.Haskell.Tools.Refactor.RefactorBase.LocalRefactorT
         Language.Haskell.Tools.AST.Ann.IdDom
         Language.Haskell.Tools.Refactor.RefactorBase.Refactor
         ()
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
d8fd7302aefd5b64870e3ddf13ecfc2b
  tryOut :: GHC.Base.String -> GHC.Base.String -> GHC.Types.IO ()
  {- Arity: 3,
     Unfolding: InlineRule (0, True, True)
                ExtensionOrganizer.tryOut1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <()>_R)) -}
3c7315fedbc893886c02cbe60f696367
  tryOut1 ::
    GHC.Base.String
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 3,
     Unfolding: (Language.Haskell.Tools.Refactor.Prepare.tryRefactor1
                   ExtensionOrganizer.tryOut2) -}
e9784f2faaa7615acc7e039fa79e376b
  tryOut2 ::
    SrcLoc.RealSrcSpan
    -> Language.Haskell.Tools.Refactor.RefactorBase.Refactoring
         Language.Haskell.Tools.AST.Ann.IdDom
  {- Arity: 3, Strictness: <L,U><S,1*U(U,U)><L,A>,
     Unfolding: InlineRule (3, True, False)
                (\ (x :: SrcLoc.RealSrcSpan)
                   (eta :: Language.Haskell.Tools.Refactor.RefactorBase.ModuleDom
                             Language.Haskell.Tools.AST.Ann.IdDom)
                   (eta1 :: [Language.Haskell.Tools.Refactor.RefactorBase.ModuleDom
                               Language.Haskell.Tools.AST.Ann.IdDom]) ->
                 case eta of ww { (,) ww12 ww13 ->
                 Language.Haskell.Tools.Refactor.RefactorBase.$wlocalRefactoring
                   @ Language.Haskell.Tools.AST.Ann.IdDom
                   ExtensionOrganizer.$slocalRefactoring1
                     `cast`
                   (GHC.Classes.(%,%)
                      <Language.Haskell.Tools.AST.Ann.Domain
                         Language.Haskell.Tools.AST.Ann.IdDom>_N
                      (Language.Haskell.Tools.AST.SemaInfoClasses.HasModuleInfo'
                         (Trans
                              (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemanticInfo'IdDomSameInfoModuleCls[0]))
                              (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                 <Language.Haskell.Tools.AST.Ann.IdDom>_N
                                 (Sym (Language.Haskell.Tools.AST.Ann.D:R:SemaInfoClassify[3])))_N))_N)_R
                   (ExtensionOrganizer.organizeExtensions_$sorganizeExtensions x)
                   ww12
                   ww13 }) -}
"SPEC collectExtensions @ IdDom" [ALWAYS] forall ($d(%,%) :: ExtMonad.ExtDomain
                                                               Language.Haskell.Tools.AST.Ann.IdDom)
  ExtensionOrganizer.collectExtensions @ Language.Haskell.Tools.AST.Ann.IdDom
                                       $d(%,%)
  = ExtensionOrganizer.collectExtensions_$scollectExtensions
"SPEC organizeExtensions @ IdDom" [ALWAYS] forall ($d(%,%) :: ExtMonad.ExtDomain
                                                                Language.Haskell.Tools.AST.Ann.IdDom)
  ExtensionOrganizer.organizeExtensions @ Language.Haskell.Tools.AST.Ann.IdDom
                                        $d(%,%)
  = ExtensionOrganizer.organizeExtensions_$sorganizeExtensions
"SPEC/ExtensionOrganizer $fApplicativeStateT @ Ghc _" [ALWAYS] forall @ s
                                                                      ($dMonad :: GHC.Base.Monad
                                                                                    GhcMonad.Ghc)
                                                                      ($dFunctor :: GHC.Base.Functor
                                                                                      GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT @ GhcMonad.Ghc
                                                     @ s
                                                     $dFunctor
                                                     $dMonad
  = ExtensionOrganizer.$s$fApplicativeStateT @ s
"SPEC/ExtensionOrganizer $fApplicativeStateT_$c<*> @ Ghc _" [ALWAYS] forall @ s
                                                                            ($dMonad :: GHC.Base.Monad
                                                                                          GhcMonad.Ghc)
                                                                            ($dFunctor :: GHC.Base.Functor
                                                                                            GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$c<*> @ GhcMonad.Ghc
                                                           @ s
                                                           $dFunctor
                                                           $dMonad
  = ExtensionOrganizer.$s$fApplicativeStateT_$s$fApplicativeStateT_$c<*>
      @ s
"SPEC/ExtensionOrganizer $fApplicativeStateT_$cp1Applicative @ Ghc _" [ALWAYS] forall @ s
                                                                                      ($dMonad :: GHC.Base.Monad
                                                                                                    GhcMonad.Ghc)
                                                                                      ($dFunctor :: GHC.Base.Functor
                                                                                                      GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$cp1Applicative @ GhcMonad.Ghc
                                                                     @ s
                                                                     $dFunctor
                                                                     $dMonad
  = ExtensionOrganizer.$s$fApplicativeStateT_$s$fApplicativeStateT_$cp1Applicative
      @ s
"SPEC/ExtensionOrganizer $fApplicativeStateT_$cpure @ Ghc _" [ALWAYS] forall @ s
                                                                             ($dMonad :: GHC.Base.Monad
                                                                                           GhcMonad.Ghc)
                                                                             ($dFunctor :: GHC.Base.Functor
                                                                                             GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fApplicativeStateT_$cpure @ GhcMonad.Ghc
                                                            @ s
                                                            $dFunctor
                                                            $dMonad
  = ExtensionOrganizer.$s$fApplicativeStateT_$s$fApplicativeStateT_$cpure
      @ s
"SPEC/ExtensionOrganizer $fDataImportInfo @ Var" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                              Var.Var)
  Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImportInfo @ Var.Var
                                                            $dData
  = ExtensionOrganizer.$s$fDataImportInfo
"SPEC/ExtensionOrganizer $fDataImportInfo_$cdataCast2 @ Var" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                          Var.Var)
  Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImportInfo_$cdataCast2 @ Var.Var
                                                                        $dData
  = ExtensionOrganizer.$s$fDataImportInfo_$s$fDataImportInfo_$cdataCast2
"SPEC/ExtensionOrganizer $fDataImportInfo_$cdataTypeOf @ Var" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                           Var.Var)
  Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImportInfo_$cdataTypeOf @ Var.Var
                                                                         $dData
  = ExtensionOrganizer.$s$fDataImportInfo_$s$fDataImportInfo_$cdataTypeOf
"SPEC/ExtensionOrganizer $fDataImportInfo_$ctoConstr @ Var" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                         Var.Var)
  Language.Haskell.Tools.AST.SemaInfoTypes.$fDataImportInfo_$ctoConstr @ Var.Var
                                                                       $dData
  = ExtensionOrganizer.$s$fDataImportInfo_$s$fDataImportInfo_$ctoConstr
"SPEC/ExtensionOrganizer $fDataModuleInfo @ Var" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                              Var.Var)
  Language.Haskell.Tools.AST.SemaInfoTypes.$fDataModuleInfo @ Var.Var
                                                            $dData
  = ExtensionOrganizer.$s$fDataModuleInfo
"SPEC/ExtensionOrganizer $fDataModuleInfo_$cdataCast2 @ Var" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                          Var.Var)
  Language.Haskell.Tools.AST.SemaInfoTypes.$fDataModuleInfo_$cdataCast2 @ Var.Var
                                                                        $dData
  = ExtensionOrganizer.$s$fDataModuleInfo_$s$fDataModuleInfo_$cdataCast2
"SPEC/ExtensionOrganizer $fDataModuleInfo_$cdataTypeOf @ Var" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                           Var.Var)
  Language.Haskell.Tools.AST.SemaInfoTypes.$fDataModuleInfo_$cdataTypeOf @ Var.Var
                                                                         $dData
  = ExtensionOrganizer.$s$fDataModuleInfo_$s$fDataModuleInfo_$cdataTypeOf
"SPEC/ExtensionOrganizer $fDataModuleInfo_$ctoConstr @ Var" [ALWAYS] forall ($dData :: Data.Data.Data
                                                                                         Var.Var)
  Language.Haskell.Tools.AST.SemaInfoTypes.$fDataModuleInfo_$ctoConstr @ Var.Var
                                                                       $dData
  = ExtensionOrganizer.$s$fDataModuleInfo_$s$fDataModuleInfo_$ctoConstr
"SPEC/ExtensionOrganizer $fDataUModule @ IdDom @ SrcTemplateStage" [ALWAYS] forall ($dSourceInfo :: Language.Haskell.Tools.AST.Ann.SourceInfo
                                                                                                      Language.Haskell.Tools.AST.Ann.SrcTemplateStage)
                                                                                   ($dDomain :: Language.Haskell.Tools.AST.Ann.Domain
                                                                                                  Language.Haskell.Tools.AST.Ann.IdDom)
  Language.Haskell.Tools.AST.Instances.Data.$fDataUModule @ Language.Haskell.Tools.AST.Ann.IdDom
                                                          @ Language.Haskell.Tools.AST.Ann.SrcTemplateStage
                                                          $dDomain
                                                          $dSourceInfo
  = ExtensionOrganizer.$s$fDataUModule
"SPEC/ExtensionOrganizer $fDomaind @ IdDom" [ALWAYS] forall ($dShow4 :: GHC.Show.Show
                                                                          (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                             Language.Haskell.Tools.AST.Ann.IdDom
                                                                             Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                            ($dShow3 :: GHC.Show.Show
                                                                          (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                             Language.Haskell.Tools.AST.Ann.IdDom
                                                                             Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                            ($dShow2 :: GHC.Show.Show
                                                                          (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                             Language.Haskell.Tools.AST.Ann.IdDom
                                                                             Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                            ($dShow1 :: GHC.Show.Show
                                                                          (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                             Language.Haskell.Tools.AST.Ann.IdDom
                                                                             Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                            ($dShow :: GHC.Show.Show
                                                                         (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                            Language.Haskell.Tools.AST.Ann.IdDom
                                                                            Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                            ($dData5 :: Data.Data.Data
                                                                          (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                             Language.Haskell.Tools.AST.Ann.IdDom
                                                                             Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                            ($dData4 :: Data.Data.Data
                                                                          (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                             Language.Haskell.Tools.AST.Ann.IdDom
                                                                             Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                            ($dData3 :: Data.Data.Data
                                                                          (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                             Language.Haskell.Tools.AST.Ann.IdDom
                                                                             Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                            ($dData2 :: Data.Data.Data
                                                                          (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                             Language.Haskell.Tools.AST.Ann.IdDom
                                                                             Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                            ($dData1 :: Data.Data.Data
                                                                          (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                             Language.Haskell.Tools.AST.Ann.IdDom
                                                                             Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                            ($d~ :: Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                      Language.Haskell.Tools.AST.Ann.IdDom
                                                                      Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls
                                                                    Data.Type.Equality.~ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo)
                                                            ($dData :: Data.Data.Data
                                                                         Language.Haskell.Tools.AST.Ann.IdDom)
                                                            ($dTypeable :: Data.Typeable.Internal.Typeable
                                                                             Language.Haskell.Tools.AST.Ann.IdDom)
  Language.Haskell.Tools.AST.Ann.$fDomaind @ Language.Haskell.Tools.AST.Ann.IdDom
                                           $dTypeable
                                           $dData
                                           $d~
                                           $dData1
                                           $dData2
                                           $dData3
                                           $dData4
                                           $dData5
                                           $dShow
                                           $dShow1
                                           $dShow2
                                           $dShow3
                                           $dShow4
  = ExtensionOrganizer.$s$fDataUModule_$s$fDomaind
"SPEC/ExtensionOrganizer $fDomaind_$cp10Domain @ IdDom" [ALWAYS] forall ($dShow4 :: GHC.Show.Show
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                        ($dShow3 :: GHC.Show.Show
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                        ($dShow2 :: GHC.Show.Show
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                        ($dShow1 :: GHC.Show.Show
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                        ($dShow :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                        ($dData5 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                        ($dData4 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                        ($dData3 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                        ($dData2 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                        ($dData1 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                        ($d~ :: Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                  Language.Haskell.Tools.AST.Ann.IdDom
                                                                                  Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls
                                                                                Data.Type.Equality.~ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo)
                                                                        ($dData :: Data.Data.Data
                                                                                     Language.Haskell.Tools.AST.Ann.IdDom)
                                                                        ($dTypeable :: Data.Typeable.Internal.Typeable
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom)
  Language.Haskell.Tools.AST.Ann.$fDomaind_$cp10Domain @ Language.Haskell.Tools.AST.Ann.IdDom
                                                       $dTypeable
                                                       $dData
                                                       $d~
                                                       $dData1
                                                       $dData2
                                                       $dData3
                                                       $dData4
                                                       $dData5
                                                       $dShow
                                                       $dShow1
                                                       $dShow2
                                                       $dShow3
                                                       $dShow4
  = ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp10Domain
"SPEC/ExtensionOrganizer $fDomaind_$cp11Domain @ IdDom" [ALWAYS] forall ($dShow4 :: GHC.Show.Show
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                        ($dShow3 :: GHC.Show.Show
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                        ($dShow2 :: GHC.Show.Show
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                        ($dShow1 :: GHC.Show.Show
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                        ($dShow :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                        ($dData5 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                        ($dData4 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                        ($dData3 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                        ($dData2 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                        ($dData1 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                        ($d~ :: Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                  Language.Haskell.Tools.AST.Ann.IdDom
                                                                                  Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls
                                                                                Data.Type.Equality.~ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo)
                                                                        ($dData :: Data.Data.Data
                                                                                     Language.Haskell.Tools.AST.Ann.IdDom)
                                                                        ($dTypeable :: Data.Typeable.Internal.Typeable
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom)
  Language.Haskell.Tools.AST.Ann.$fDomaind_$cp11Domain @ Language.Haskell.Tools.AST.Ann.IdDom
                                                       $dTypeable
                                                       $dData
                                                       $d~
                                                       $dData1
                                                       $dData2
                                                       $dData3
                                                       $dData4
                                                       $dData5
                                                       $dShow
                                                       $dShow1
                                                       $dShow2
                                                       $dShow3
                                                       $dShow4
  = ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp11Domain
"SPEC/ExtensionOrganizer $fDomaind_$cp12Domain @ IdDom" [ALWAYS] forall ($dShow4 :: GHC.Show.Show
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                        ($dShow3 :: GHC.Show.Show
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                        ($dShow2 :: GHC.Show.Show
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                        ($dShow1 :: GHC.Show.Show
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                        ($dShow :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                        ($dData5 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                        ($dData4 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                        ($dData3 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                        ($dData2 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                        ($dData1 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                        ($d~ :: Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                  Language.Haskell.Tools.AST.Ann.IdDom
                                                                                  Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls
                                                                                Data.Type.Equality.~ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo)
                                                                        ($dData :: Data.Data.Data
                                                                                     Language.Haskell.Tools.AST.Ann.IdDom)
                                                                        ($dTypeable :: Data.Typeable.Internal.Typeable
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom)
  Language.Haskell.Tools.AST.Ann.$fDomaind_$cp12Domain @ Language.Haskell.Tools.AST.Ann.IdDom
                                                       $dTypeable
                                                       $dData
                                                       $d~
                                                       $dData1
                                                       $dData2
                                                       $dData3
                                                       $dData4
                                                       $dData5
                                                       $dShow
                                                       $dShow1
                                                       $dShow2
                                                       $dShow3
                                                       $dShow4
  = ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp12Domain
"SPEC/ExtensionOrganizer $fDomaind_$cp13Domain @ IdDom" [ALWAYS] forall ($dShow4 :: GHC.Show.Show
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                        ($dShow3 :: GHC.Show.Show
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                        ($dShow2 :: GHC.Show.Show
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                        ($dShow1 :: GHC.Show.Show
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                        ($dShow :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                        ($dData5 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                        ($dData4 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                        ($dData3 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                        ($dData2 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                        ($dData1 :: Data.Data.Data
                                                                                      (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom
                                                                                         Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                        ($d~ :: Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                  Language.Haskell.Tools.AST.Ann.IdDom
                                                                                  Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls
                                                                                Data.Type.Equality.~ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo)
                                                                        ($dData :: Data.Data.Data
                                                                                     Language.Haskell.Tools.AST.Ann.IdDom)
                                                                        ($dTypeable :: Data.Typeable.Internal.Typeable
                                                                                         Language.Haskell.Tools.AST.Ann.IdDom)
  Language.Haskell.Tools.AST.Ann.$fDomaind_$cp13Domain @ Language.Haskell.Tools.AST.Ann.IdDom
                                                       $dTypeable
                                                       $dData
                                                       $d~
                                                       $dData1
                                                       $dData2
                                                       $dData3
                                                       $dData4
                                                       $dData5
                                                       $dShow
                                                       $dShow1
                                                       $dShow2
                                                       $dShow3
                                                       $dShow4
  = ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp13Domain
"SPEC/ExtensionOrganizer $fDomaind_$cp2Domain @ IdDom" [ALWAYS] forall ($dShow4 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                       ($dShow3 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                       ($dShow2 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                       ($dShow1 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                       ($dShow :: GHC.Show.Show
                                                                                    (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                       Language.Haskell.Tools.AST.Ann.IdDom
                                                                                       Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                       ($dData5 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                       ($dData4 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                       ($dData3 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                       ($dData2 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                       ($dData1 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                       ($d~ :: Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                 Language.Haskell.Tools.AST.Ann.IdDom
                                                                                 Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls
                                                                               Data.Type.Equality.~ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo)
                                                                       ($dData :: Data.Data.Data
                                                                                    Language.Haskell.Tools.AST.Ann.IdDom)
                                                                       ($dTypeable :: Data.Typeable.Internal.Typeable
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom)
  Language.Haskell.Tools.AST.Ann.$fDomaind_$cp2Domain @ Language.Haskell.Tools.AST.Ann.IdDom
                                                      $dTypeable
                                                      $dData
                                                      $d~
                                                      $dData1
                                                      $dData2
                                                      $dData3
                                                      $dData4
                                                      $dData5
                                                      $dShow
                                                      $dShow1
                                                      $dShow2
                                                      $dShow3
                                                      $dShow4
  = ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp2Domain
"SPEC/ExtensionOrganizer $fDomaind_$cp3Domain @ IdDom" [ALWAYS] forall ($dShow4 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                       ($dShow3 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                       ($dShow2 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                       ($dShow1 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                       ($dShow :: GHC.Show.Show
                                                                                    (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                       Language.Haskell.Tools.AST.Ann.IdDom
                                                                                       Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                       ($dData5 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                       ($dData4 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                       ($dData3 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                       ($dData2 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                       ($dData1 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                       ($d~ :: Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                 Language.Haskell.Tools.AST.Ann.IdDom
                                                                                 Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls
                                                                               Data.Type.Equality.~ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo)
                                                                       ($dData :: Data.Data.Data
                                                                                    Language.Haskell.Tools.AST.Ann.IdDom)
                                                                       ($dTypeable :: Data.Typeable.Internal.Typeable
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom)
  Language.Haskell.Tools.AST.Ann.$fDomaind_$cp3Domain @ Language.Haskell.Tools.AST.Ann.IdDom
                                                      $dTypeable
                                                      $dData
                                                      $d~
                                                      $dData1
                                                      $dData2
                                                      $dData3
                                                      $dData4
                                                      $dData5
                                                      $dShow
                                                      $dShow1
                                                      $dShow2
                                                      $dShow3
                                                      $dShow4
  = ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp3Domain
"SPEC/ExtensionOrganizer $fDomaind_$cp4Domain @ IdDom" [ALWAYS] forall ($dShow4 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                       ($dShow3 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                       ($dShow2 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                       ($dShow1 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                       ($dShow :: GHC.Show.Show
                                                                                    (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                       Language.Haskell.Tools.AST.Ann.IdDom
                                                                                       Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                       ($dData5 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                       ($dData4 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                       ($dData3 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                       ($dData2 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                       ($dData1 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                       ($d~ :: Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                 Language.Haskell.Tools.AST.Ann.IdDom
                                                                                 Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls
                                                                               Data.Type.Equality.~ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo)
                                                                       ($dData :: Data.Data.Data
                                                                                    Language.Haskell.Tools.AST.Ann.IdDom)
                                                                       ($dTypeable :: Data.Typeable.Internal.Typeable
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom)
  Language.Haskell.Tools.AST.Ann.$fDomaind_$cp4Domain @ Language.Haskell.Tools.AST.Ann.IdDom
                                                      $dTypeable
                                                      $dData
                                                      $d~
                                                      $dData1
                                                      $dData2
                                                      $dData3
                                                      $dData4
                                                      $dData5
                                                      $dShow
                                                      $dShow1
                                                      $dShow2
                                                      $dShow3
                                                      $dShow4
  = ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp4Domain
"SPEC/ExtensionOrganizer $fDomaind_$cp5Domain @ IdDom" [ALWAYS] forall ($dShow4 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                       ($dShow3 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                       ($dShow2 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                       ($dShow1 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                       ($dShow :: GHC.Show.Show
                                                                                    (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                       Language.Haskell.Tools.AST.Ann.IdDom
                                                                                       Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                       ($dData5 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                       ($dData4 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                       ($dData3 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                       ($dData2 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                       ($dData1 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                       ($d~ :: Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                 Language.Haskell.Tools.AST.Ann.IdDom
                                                                                 Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls
                                                                               Data.Type.Equality.~ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo)
                                                                       ($dData :: Data.Data.Data
                                                                                    Language.Haskell.Tools.AST.Ann.IdDom)
                                                                       ($dTypeable :: Data.Typeable.Internal.Typeable
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom)
  Language.Haskell.Tools.AST.Ann.$fDomaind_$cp5Domain @ Language.Haskell.Tools.AST.Ann.IdDom
                                                      $dTypeable
                                                      $dData
                                                      $d~
                                                      $dData1
                                                      $dData2
                                                      $dData3
                                                      $dData4
                                                      $dData5
                                                      $dShow
                                                      $dShow1
                                                      $dShow2
                                                      $dShow3
                                                      $dShow4
  = ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp5Domain
"SPEC/ExtensionOrganizer $fDomaind_$cp6Domain @ IdDom" [ALWAYS] forall ($dShow4 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                       ($dShow3 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                       ($dShow2 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                       ($dShow1 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                       ($dShow :: GHC.Show.Show
                                                                                    (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                       Language.Haskell.Tools.AST.Ann.IdDom
                                                                                       Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                       ($dData5 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                       ($dData4 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                       ($dData3 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                       ($dData2 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                       ($dData1 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                       ($d~ :: Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                 Language.Haskell.Tools.AST.Ann.IdDom
                                                                                 Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls
                                                                               Data.Type.Equality.~ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo)
                                                                       ($dData :: Data.Data.Data
                                                                                    Language.Haskell.Tools.AST.Ann.IdDom)
                                                                       ($dTypeable :: Data.Typeable.Internal.Typeable
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom)
  Language.Haskell.Tools.AST.Ann.$fDomaind_$cp6Domain @ Language.Haskell.Tools.AST.Ann.IdDom
                                                      $dTypeable
                                                      $dData
                                                      $d~
                                                      $dData1
                                                      $dData2
                                                      $dData3
                                                      $dData4
                                                      $dData5
                                                      $dShow
                                                      $dShow1
                                                      $dShow2
                                                      $dShow3
                                                      $dShow4
  = ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp6Domain
"SPEC/ExtensionOrganizer $fDomaind_$cp7Domain @ IdDom" [ALWAYS] forall ($dShow4 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                       ($dShow3 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                       ($dShow2 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                       ($dShow1 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                       ($dShow :: GHC.Show.Show
                                                                                    (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                       Language.Haskell.Tools.AST.Ann.IdDom
                                                                                       Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                       ($dData5 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                       ($dData4 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                       ($dData3 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                       ($dData2 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                       ($dData1 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                       ($d~ :: Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                 Language.Haskell.Tools.AST.Ann.IdDom
                                                                                 Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls
                                                                               Data.Type.Equality.~ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo)
                                                                       ($dData :: Data.Data.Data
                                                                                    Language.Haskell.Tools.AST.Ann.IdDom)
                                                                       ($dTypeable :: Data.Typeable.Internal.Typeable
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom)
  Language.Haskell.Tools.AST.Ann.$fDomaind_$cp7Domain @ Language.Haskell.Tools.AST.Ann.IdDom
                                                      $dTypeable
                                                      $dData
                                                      $d~
                                                      $dData1
                                                      $dData2
                                                      $dData3
                                                      $dData4
                                                      $dData5
                                                      $dShow
                                                      $dShow1
                                                      $dShow2
                                                      $dShow3
                                                      $dShow4
  = ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp7Domain
"SPEC/ExtensionOrganizer $fDomaind_$cp8Domain @ IdDom" [ALWAYS] forall ($dShow4 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                       ($dShow3 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                       ($dShow2 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                       ($dShow1 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                       ($dShow :: GHC.Show.Show
                                                                                    (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                       Language.Haskell.Tools.AST.Ann.IdDom
                                                                                       Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                       ($dData5 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                       ($dData4 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                       ($dData3 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                       ($dData2 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                       ($dData1 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                       ($d~ :: Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                 Language.Haskell.Tools.AST.Ann.IdDom
                                                                                 Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls
                                                                               Data.Type.Equality.~ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo)
                                                                       ($dData :: Data.Data.Data
                                                                                    Language.Haskell.Tools.AST.Ann.IdDom)
                                                                       ($dTypeable :: Data.Typeable.Internal.Typeable
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom)
  Language.Haskell.Tools.AST.Ann.$fDomaind_$cp8Domain @ Language.Haskell.Tools.AST.Ann.IdDom
                                                      $dTypeable
                                                      $dData
                                                      $d~
                                                      $dData1
                                                      $dData2
                                                      $dData3
                                                      $dData4
                                                      $dData5
                                                      $dShow
                                                      $dShow1
                                                      $dShow2
                                                      $dShow3
                                                      $dShow4
  = ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp8Domain
"SPEC/ExtensionOrganizer $fDomaind_$cp9Domain @ IdDom" [ALWAYS] forall ($dShow4 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                       ($dShow3 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                       ($dShow2 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                       ($dShow1 :: GHC.Show.Show
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                       ($dShow :: GHC.Show.Show
                                                                                    (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                       Language.Haskell.Tools.AST.Ann.IdDom
                                                                                       Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                       ($dData5 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoWildcardCls))
                                                                       ($dData4 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoModuleCls))
                                                                       ($dData3 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoImportCls))
                                                                       ($dData2 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoExprCls))
                                                                       ($dData1 :: Data.Data.Data
                                                                                     (Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom
                                                                                        Language.Haskell.Tools.AST.Ann.SameInfoNameCls))
                                                                       ($d~ :: Language.Haskell.Tools.AST.Ann.SemanticInfo'
                                                                                 Language.Haskell.Tools.AST.Ann.IdDom
                                                                                 Language.Haskell.Tools.AST.Ann.SameInfoDefaultCls
                                                                               Data.Type.Equality.~ Language.Haskell.Tools.AST.SemaInfoTypes.NoSemanticInfo)
                                                                       ($dData :: Data.Data.Data
                                                                                    Language.Haskell.Tools.AST.Ann.IdDom)
                                                                       ($dTypeable :: Data.Typeable.Internal.Typeable
                                                                                        Language.Haskell.Tools.AST.Ann.IdDom)
  Language.Haskell.Tools.AST.Ann.$fDomaind_$cp9Domain @ Language.Haskell.Tools.AST.Ann.IdDom
                                                      $dTypeable
                                                      $dData
                                                      $d~
                                                      $dData1
                                                      $dData2
                                                      $dData3
                                                      $dData4
                                                      $dData5
                                                      $dShow
                                                      $dShow1
                                                      $dShow2
                                                      $dShow3
                                                      $dShow4
  = ExtensionOrganizer.$s$fDataUModule_$s$fDomaind_$cp9Domain
"SPEC/ExtensionOrganizer $fFunctorStateT @ Ghc _" [ALWAYS] forall @ s
                                                                  ($dFunctor :: GHC.Base.Functor
                                                                                  GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fFunctorStateT @ GhcMonad.Ghc
                                                 @ s
                                                 $dFunctor
  = ExtensionOrganizer.$s$fApplicativeStateT_$s$fFunctorStateT @ s
"SPEC/ExtensionOrganizer $fFunctorStateT_$cfmap @ Ghc _" [ALWAYS] forall @ s
                                                                         ($dFunctor :: GHC.Base.Functor
                                                                                         GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fFunctorStateT_$cfmap @ GhcMonad.Ghc
                                                        @ s
                                                        $dFunctor
  = ExtensionOrganizer.$s$fApplicativeStateT_$s$fFunctorStateT_$cfmap
      @ s
"SPEC/ExtensionOrganizer $fMonadStateT @ Ghc _" [ALWAYS] forall @ s
                                                                ($dMonad :: GHC.Base.Monad
                                                                              GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fMonadStateT @ GhcMonad.Ghc
                                               @ s
                                               $dMonad
  = ExtensionOrganizer.$s$fMonadStateT @ s
"SPEC/ExtensionOrganizer $fMonadStateT_$c>> @ Ghc _" [ALWAYS] forall @ s
                                                                     ($dMonad :: GHC.Base.Monad
                                                                                   GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>> @ GhcMonad.Ghc
                                                    @ s
                                                    $dMonad
  = ExtensionOrganizer.$s$fMonadStateT_$s$fMonadStateT_$c>> @ s
"SPEC/ExtensionOrganizer $fMonadStateT_$c>>= @ Ghc _" [ALWAYS] forall @ s
                                                                      ($dMonad :: GHC.Base.Monad
                                                                                    GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$c>>= @ GhcMonad.Ghc
                                                     @ s
                                                     $dMonad
  = ExtensionOrganizer.$s$fMonadStateT_$s$fMonadStateT_$c>>= @ s
"SPEC/ExtensionOrganizer $fMonadStateT_$cfail @ Ghc _" [ALWAYS] forall @ s
                                                                       ($dMonad :: GHC.Base.Monad
                                                                                     GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cfail @ GhcMonad.Ghc
                                                      @ s
                                                      $dMonad
  = ExtensionOrganizer.$s$fMonadStateT_$s$fMonadStateT_$cfail @ s
"SPEC/ExtensionOrganizer $fMonadStateT_$cp1Monad @ Ghc _" [ALWAYS] forall @ s
                                                                          ($dMonad :: GHC.Base.Monad
                                                                                        GhcMonad.Ghc)
  Control.Monad.Trans.State.Lazy.$fMonadStateT_$cp1Monad @ GhcMonad.Ghc
                                                         @ s
                                                         $dMonad
  = ExtensionOrganizer.$s$fMonadStateT_$s$fMonadStateT_$cp1Monad @ s
"SPEC/ExtensionOrganizer $fRefMonadswr @ (StateT
                                           (Map Extension [SrcSpan]) Ghc) @ Proxy" [ALWAYS] forall ($dMonad1 :: GHC.Base.Monad
                                                                                                                                                                   Data.Proxy.Proxy)
                                                                                                                                                    ($dApplicative1 :: GHC.Base.Applicative
                                                                                                                                                                         Data.Proxy.Proxy)
                                                                                                                                                    ($dFunctor1 :: GHC.Base.Functor
                                                                                                                                                                     Data.Proxy.Proxy)
                                                                                                                                                    ($dMonad :: GHC.Base.Monad
                                                                                                                                                                  (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                     (Data.Map.Base.Map
                                                                                                                                                                        GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                        [SrcLoc.SrcSpan])
                                                                                                                                                                     GhcMonad.Ghc))
                                                                                                                                                    ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                        (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                           (Data.Map.Base.Map
                                                                                                                                                                              GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                              [SrcLoc.SrcSpan])
                                                                                                                                                                           GhcMonad.Ghc))
                                                                                                                                                    ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                    (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                       (Data.Map.Base.Map
                                                                                                                                                                          GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                          [SrcLoc.SrcSpan])
                                                                                                                                                                       GhcMonad.Ghc))
  Control.Reference.Representation.$fRefMonadswr @ (Control.Monad.Trans.State.Lazy.StateT
                                                      (Data.Map.Base.Map
                                                         GHC.LanguageExtensions.Type.Extension
                                                         [SrcLoc.SrcSpan])
                                                      GhcMonad.Ghc)
                                                 @ Data.Proxy.Proxy
                                                 $dFunctor
                                                 $dApplicative
                                                 $dMonad
                                                 $dFunctor1
                                                 $dApplicative1
                                                 $dMonad1
  = ExtensionOrganizer.$s$fRefMonadswr
"SPEC/ExtensionOrganizer $fRefMonadswr_$cp4RefMonads @ (StateT
                                                         (Map Extension [SrcSpan]) Ghc) @ Proxy" [ALWAYS] forall ($dMonad1 :: GHC.Base.Monad
                                                                                                                                                                                               Data.Proxy.Proxy)
                                                                                                                                                                                ($dApplicative1 :: GHC.Base.Applicative
                                                                                                                                                                                                     Data.Proxy.Proxy)
                                                                                                                                                                                ($dFunctor1 :: GHC.Base.Functor
                                                                                                                                                                                                 Data.Proxy.Proxy)
                                                                                                                                                                                ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                              (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                 (Data.Map.Base.Map
                                                                                                                                                                                                    GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                    [SrcLoc.SrcSpan])
                                                                                                                                                                                                 GhcMonad.Ghc))
                                                                                                                                                                                ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                    (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                       (Data.Map.Base.Map
                                                                                                                                                                                                          GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                          [SrcLoc.SrcSpan])
                                                                                                                                                                                                       GhcMonad.Ghc))
                                                                                                                                                                                ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                   (Data.Map.Base.Map
                                                                                                                                                                                                      GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                      [SrcLoc.SrcSpan])
                                                                                                                                                                                                   GhcMonad.Ghc))
  Control.Reference.Representation.$fRefMonadswr_$cp4RefMonads @ (Control.Monad.Trans.State.Lazy.StateT
                                                                    (Data.Map.Base.Map
                                                                       GHC.LanguageExtensions.Type.Extension
                                                                       [SrcLoc.SrcSpan])
                                                                    GhcMonad.Ghc)
                                                               @ Data.Proxy.Proxy
                                                               $dFunctor
                                                               $dApplicative
                                                               $dMonad
                                                               $dFunctor1
                                                               $dApplicative1
                                                               $dMonad1
  = ExtensionOrganizer.$s$fRefMonadswr_$s$fRefMonadswr_$cp4RefMonads
"SPEC/ExtensionOrganizer $fRefMonadswr_$cp5RefMonads @ (StateT
                                                         (Map Extension [SrcSpan]) Ghc) @ Proxy" [ALWAYS] forall ($dMonad1 :: GHC.Base.Monad
                                                                                                                                                                                               Data.Proxy.Proxy)
                                                                                                                                                                                ($dApplicative1 :: GHC.Base.Applicative
                                                                                                                                                                                                     Data.Proxy.Proxy)
                                                                                                                                                                                ($dFunctor1 :: GHC.Base.Functor
                                                                                                                                                                                                 Data.Proxy.Proxy)
                                                                                                                                                                                ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                              (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                 (Data.Map.Base.Map
                                                                                                                                                                                                    GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                    [SrcLoc.SrcSpan])
                                                                                                                                                                                                 GhcMonad.Ghc))
                                                                                                                                                                                ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                    (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                       (Data.Map.Base.Map
                                                                                                                                                                                                          GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                          [SrcLoc.SrcSpan])
                                                                                                                                                                                                       GhcMonad.Ghc))
                                                                                                                                                                                ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                   (Data.Map.Base.Map
                                                                                                                                                                                                      GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                      [SrcLoc.SrcSpan])
                                                                                                                                                                                                   GhcMonad.Ghc))
  Control.Reference.Representation.$fRefMonadswr_$cp5RefMonads @ (Control.Monad.Trans.State.Lazy.StateT
                                                                    (Data.Map.Base.Map
                                                                       GHC.LanguageExtensions.Type.Extension
                                                                       [SrcLoc.SrcSpan])
                                                                    GhcMonad.Ghc)
                                                               @ Data.Proxy.Proxy
                                                               $dFunctor
                                                               $dApplicative
                                                               $dMonad
                                                               $dFunctor1
                                                               $dApplicative1
                                                               $dMonad1
  = ExtensionOrganizer.$s$fRefMonadswr_$s$fRefMonadswr_$cp5RefMonads
"SPEC/ExtensionOrganizer $fRefMonadswr_$cp6RefMonads @ (StateT
                                                         (Map Extension [SrcSpan]) Ghc) @ Proxy" [ALWAYS] forall ($dMonad1 :: GHC.Base.Monad
                                                                                                                                                                                               Data.Proxy.Proxy)
                                                                                                                                                                                ($dApplicative1 :: GHC.Base.Applicative
                                                                                                                                                                                                     Data.Proxy.Proxy)
                                                                                                                                                                                ($dFunctor1 :: GHC.Base.Functor
                                                                                                                                                                                                 Data.Proxy.Proxy)
                                                                                                                                                                                ($dMonad :: GHC.Base.Monad
                                                                                                                                                                                              (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                 (Data.Map.Base.Map
                                                                                                                                                                                                    GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                    [SrcLoc.SrcSpan])
                                                                                                                                                                                                 GhcMonad.Ghc))
                                                                                                                                                                                ($dApplicative :: GHC.Base.Applicative
                                                                                                                                                                                                    (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                       (Data.Map.Base.Map
                                                                                                                                                                                                          GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                          [SrcLoc.SrcSpan])
                                                                                                                                                                                                       GhcMonad.Ghc))
                                                                                                                                                                                ($dFunctor :: GHC.Base.Functor
                                                                                                                                                                                                (Control.Monad.Trans.State.Lazy.StateT
                                                                                                                                                                                                   (Data.Map.Base.Map
                                                                                                                                                                                                      GHC.LanguageExtensions.Type.Extension
                                                                                                                                                                                                      [SrcLoc.SrcSpan])
                                                                                                                                                                                                   GhcMonad.Ghc))
  Control.Reference.Representation.$fRefMonadswr_$cp6RefMonads @ (Control.Monad.Trans.State.Lazy.StateT
                                                                    (Data.Map.Base.Map
                                                                       GHC.LanguageExtensions.Type.Extension
                                                                       [SrcLoc.SrcSpan])
                                                                    GhcMonad.Ghc)
                                                               @ Data.Proxy.Proxy
                                                               $dFunctor
                                                               $dApplicative
                                                               $dMonad
                                                               $dFunctor1
                                                               $dApplicative1
                                                               $dMonad1
  = ExtensionOrganizer.$s$fRefMonadswr_$s$fRefMonadswr_$cp6RefMonads
"SPEC/ExtensionOrganizer $fShowImportInfo @ Var" [ALWAYS] forall ($dOutputable :: Outputable.Outputable
                                                                                    Var.Var)
  Language.Haskell.Tools.AST.SemaInfoTypes.$fShowImportInfo @ Var.Var
                                                            $dOutputable
  = ExtensionOrganizer.$s$fDataUModule_$s$fShowImportInfo
"SPEC/ExtensionOrganizer $fShowImportInfo_$cshowsPrec @ Var" [ALWAYS] forall ($dOutputable :: Outputable.Outputable
                                                                                                Var.Var)
  Language.Haskell.Tools.AST.SemaInfoTypes.$fShowImportInfo_$cshowsPrec @ Var.Var
                                                                        $dOutputable
  = ExtensionOrganizer.$s$fDataUModule_$s$fShowImportInfo_$cshowsPrec
"SPEC/ExtensionOrganizer $fShowModuleInfo @ Var" [ALWAYS] forall ($dOutputable :: Outputable.Outputable
                                                                                    Var.Var)
  Language.Haskell.Tools.AST.SemaInfoTypes.$fShowModuleInfo @ Var.Var
                                                            $dOutputable
  = ExtensionOrganizer.$s$fDataUModule_$s$fShowModuleInfo
"SPEC/ExtensionOrganizer $fShowModuleInfo_$cshowsPrec @ Var" [ALWAYS] forall ($dOutputable :: Outputable.Outputable
                                                                                                Var.Var)
  Language.Haskell.Tools.AST.SemaInfoTypes.$fShowModuleInfo_$cshowsPrec @ Var.Var
                                                                        $dOutputable
  = ExtensionOrganizer.$s$fDataUModule_$s$fShowModuleInfo_$cshowsPrec
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

